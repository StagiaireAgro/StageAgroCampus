---
title: "PLAT4TERFOOD"
format:
  html:
    toc: true
---

## Packages

```{r, message=FALSE, warning=FALSE}
library(readxl)
library(dplyr)
library(tidyverse)
library(kableExtra)
library(gtsummary)
```

## Imporation des données

```{r,}

data <- read_excel("24407_Export.xlsx")

```

## Questions :

### 1.Pour chaque lieu. Expression des fréquences des courses (Q6)

#### Avec R natif

Dans cette option, nous utiliserons exclusivement les commandes basiques de R sans importer aucune librairie.

##### Renommage des variables

Dans cette option, il est possible de renommer immédiatement après avoir importé le jeu de données, à l’aide de la fonction names().

1.  La commande names() permet de sélectionner le nom des variables du jeu de données

2.  \[17:28\] permet de ne garder que les colonnes numéro 17 jusqu'au numéro 28

3.  L'opérateur \<- est celui de l'affectation c() est l'opérateur de concaténation. Dedans, on précise le nouveau nom des colonnes

```{r}
# On crée une copie de data 

data1 = data

# On renomme le nom des colonnes de la question 6 de l'enquête

names(data1)[17:28] <- c("Hypermarché", "Hard discount","Epiceries indépendante",
                            "Magains de surgelé","Magasins spécialisés Bio", "Marché","Directement aux agriculteur",
                            "Paniers en ligne", "Artisans et commerçants spécialisés", "Epicerie participative",
                            "Magasin alimentaire spécialisé dans le vrac", "Magasin d'aide alimentaire")
```

##### Renommage des modalités

Poursuivons avec le bon renommage des lignes des colonnes de la question 6. Etant donné qu'il faudra répéter exactement la même opération de renommage sur 13 colonnes, nous nous servirons d'une boucle for pour optimiser et éviter les copier-coller qui prend beaucoup de temps.

```{r}
# Vecteur de correspondance
modifications <- c("1" = "Plusieurs fois par semaine",
                   "2" = "1 fois par semaine",
                   "3" = "2 à 3 fois par mois",
                   "4" = "1 fois par mois",
                   "5" = "Moins d’une fois par mois",
                   "6" = "Seulement pour des événements particuliers",
                   "7" = "Jamais")

# Noms des colonnes à modifier
colonnes_a_modifier <- c("Hypermarché", "Hard discount","Epiceries indépendante",
                          	"Magains de surgelé","Magasins spécialisés Bio", "Marché","Directement aux agriculteur",
                          	"Paniers en ligne", "Artisans et commerçants spécialisés", "Epicerie participative",
                          	"Magasin alimentaire spécialisé dans le vrac", "Magasin d'aide alimentaire")

# Appliquer les modifications à chaque colonne
for (col in colonnes_a_modifier) {
  data1[[col]] <- modifications[as.character(data1[[col]])]
}

```

##### Sélection des colonnes d'intérêt

Ensuite, pour cette question, nous n'avons besoin que des colonnes portant sur la question 6 de l'enquête. Pour ce faire, nous exploitons la fonction subset(). Elle a pour objectif de renvoyer des sous-ensembles de vecteurs, de matrices ou de trames de données qui répondent à certaines conditions.

1.  Le premier argument obligatoire de subset() est le jeu de données. Ici, il s'agit de data1.

2.  Le deuxième atgument obligatoire de subset() est la condition appliquée. Ici, il s'agit d'une sélection des colonnes 17 à 28 (qui sont celles de la question 6). D'où l'écriture, select = c(17:28) qui permet de le faire.

```{r}
data1_question_6 <- subset(data1, select = c(17:28))
```

##### Calcul des fréquences

Maintenant, passons au calcul des fréquences avec la fonction lapply() Pour un jeu de données fourni, lapply() appliquera une ou des fonctions sur ce dernier. Nous entendons fonctions au sens large, c’est-à-dire que cela peut autant être des fonctions comme le type des variables, la somme etc. Les résultats renvoyés par la fonction lapply() seront au format liste.

1.  On renseigne les données qui nous intéressent dans l’argument X. Ici, c'est data1_question_6

2.  On remplit la ou les fonctions qu’on souhaite appliquer sur les données d’intérêt dans l'argument FUN. Ici, on utilisera round() pour arrondi les résultats à 2 décimales puis prop.table() pour calculer les fréquences et on multiplie par 100 pour obtenir des pourcentages.

```{r}
table_propr_courses_option_1 <- lapply(data1_question_6, function(x) round(prop.table(table(x)),2)*100)
```

##### Transformation en tableau de résultats explooitable et interprétable

Le format liste n’est pas des plus appropriés pour lire des résultats dans un rapport. C’est pourquoi, nous décidons de métamorphoser les résultats listes en tableau de résultat grâce à la fonction as.data.frame() de R de base. Au sien de la fonction as.data.frame(), nous introduisons la fonction do.call() qui construit et exécute un appel de fonction à partir d’un nom ou d’une fonction et une liste d’arguments à lui transmettre.

1.  Le premier argument de do.call() est le nom de la fonction. Ici, il s'agit de rbind() qui permet de combiner toutes nos listes par lignes. Attention, il faut s'assurer d'avoir exactement le même nombre de colonnes pour que rbind() marche. Sinon, une erreur sera renvoyée. Cette condition est bien vérifiée ici.

2.  Le deuxième argument est la liste. Dans notre cas, il s'agit de table_propr_courses_option_1.

```{r,message=FALSE,warning=FALSE}
# Tableau présentable des donénes
table_propr_courses_option_1 <- as.data.frame(do.call(rbind, table_propr_courses_option_1))
```

##### Mise en forme du tableau

Nous allons crééer et ajouter une colonne pour le libellé du lieu d'achat à l'aide de la fonction de concaténation c() et le \$. Par défaut, R place automatyiquement la nouvelle colonne créée en dernière position. Il est plus naturel et logique d'avoir le libellé du lieu d'achat en première position. Ainsi, grâce à la sélection, la concaténation et le nombre de colonnes (ncol()), nous exécutons cela. De plus, nous ajoutons le symbole % dans chaque cellule de notre tableau avec une boucle for et de la fonction paste0() qui permet de concaténer.

```{r}
# Création de la nouvelle colonne Type et de ses modalités

Type=c("Hypermarché", "Hard discount", "Epiceries indépendantes", "Magains de surgelés", "Magasins spécialisés Bio", "Marché", "Directement aux agriculteurs", "Paniers en ligne", 
                                         "Artisans et commerçants spécialisés", "Epicerie participative", "Magasin alimentaire spécialisé dans le vrac", "Magasin d'aide alimentaire")

# Ajoutons la colonne Type dans noytre tableau de résultats

table_propr_courses_option_1$Type <- Type

# Plaçons la dernière colonne Type à la première position 

table_propr_courses_option_1 <- table_propr_courses_option_1[, c(ncol(table_propr_courses_option_1), 1:(ncol(table_propr_courses_option_1)-1))]
```

```{r}
# Affichons le tableau final
table_propr_courses_option_1
```

#### Avec usage de library

-   (1) On sélectionne les données qui nous intéressent avec la fonction `select()` dans le dataframe de base (On sélectionne les données de la colonne Q6_1 à Q6_12). Pour travailler faire une action sur notre dataframe on l'outil `%>%` de la library dplyr

-   (2) On fait une mise au format long de notre nouveau dataframe à l’aide de la fonction `pivot_longer()` de la library tidyverse.

-   (3) On passe toute les données en type facteur à l'aide de la fonction `factor()` où l'on définit les levels et les labels associés.

-   (4) A l’aide de la fonction `table()` on fait un tableau de fréquence en fonction des catégories croisés (le lieux d’achat croisé avec sa régularité de fréquentation).

-   (5) A partir de ce tableau on calcul les proportion d'individu en fonction des catégories croisés que l'on multipli par 100 pour avoir des pourcentages à l'aide de la fonction `prop.table()`. On arrondi à deux chiffres après la virgule avec la fonction `round()`.

-   (6) Avec la fonction `kable()` du package KableExtra on met en forme ce tableau. On lui ajoute un style avec la fonction `kable_styling()` et on ajoute une note de fin de page avec la fonction `footnote()` qu l'on applique à kable à l'aide la `%>%`.

```{r}
#(1)
  
df_Q6 <- data %>%      
  select(Q6_1:Q6_12) 

#(2)

df_Q6_L <- df_Q6 %>%  pivot_longer(cols = Q6_1:Q6_12,
                          names_to = "Q6",
                          values_to = "value")

#(3)

df_Q6_L$Q6 <- factor(df_Q6_L$Q6, levels = paste("Q6_", seq(1:12), sep = ""), labels = c("Hypermarché, Supermarché","Hard discount","Epiceries indépendantes, de quartier, épiceries fines","Magasins de surgelés","Magasins spécialisés Bio","Marché","Directement aux agriculteurs","Paniers en ligne réalisés par un intermédiaire","Artisans et commerçants spécialisés","Epicerie participative, associative, supermarché coopératif","Magasin alimentaire spécialisé dans le vrac ou les produits locaux","Magasin d’aide alimentaire"))

df_Q6_L$value <- factor(df_Q6_L$value, levels = 1:7, labels = c("Plusieurs fois par semaine","1 fois par semaine","2 à 3 fois par mois","1 fois par mois","Moins d’une fois par mois","Seulement pour des événements particuliers","Jamais"))

#(4)

df_Q6_freq <- table(df_Q6_L$Q6, df_Q6_L$value)

#(5)

df_Q6_prop <- round(prop.table(df_Q6_freq,1)*100, 2)

#(6)

kable(df_Q6_prop, captation = "Taux de réquentation en fonction des lieux d'achat" ) %>% # mise en forme du tableau
  kable_styling(latex_options = "striped") %>%
  footnote(general = "Format des données en pourcentage",
           general_title = "Note: ",)
```

### 2.Nombre de lieux fréquentés très régulièrement (réponses 1/2) en moyenne

#### Usage de R natif

1. On sélectionne les données qui nous intéressent. On utilise la fonctione `paste()` pour créer tout les noms de colonnes qui nous intéressent.

2. On regarde pour chaque individu pour chaque lieu si il  est très fréquenté ( = 1 ou = 2). cela nous retourne le dataframe de booléens (0 = FALSE ou 1 = TRUE) . Il nous reste à sommer par ligne à l'aide de la fonction `rowSums()`

3. Pour afficher notre résultat on utilise la fontion `print()` à laquel on donne comme argument notre collage de à de la fonction `paste()` pour intégrer la moyenne arrondi à un chiffre après la virgule de notre moyenne du nombre de lieux très fréquenté
```{r}

#(1)

dt_nb_moy <- data[,paste("Q6_",1:12,sep = "")]

#(2)

nb_tres_freq <- rowSums(dt_nb_moy == 1 | dt_nb_moy == 2)

#(3)

print(paste("Les répondants fréquentent en moyenne ",round(mean(nb_tres_freq),1),
            " lieux très régulièrement (au moins une fois par semaine)"))
```
#### Avec usage de library

1.  Sélectionner les variables ou colonnes qui répondent à la question dans le jeu de données avec `select()`
2.  Vérifier que toutes les colonnes vérifient la condition via `accross()`
3.  Pour chaque individu, il faut compter le nombre de lieux qu'il a visité `rowSums()`
4.  Faire une moyenne du nombre de lieux `mean()`

```{r}
moyenne_freq <- data %>%
  select(Q6_1:Q6_12) %>%
  mutate(across(everything(), ~ .x == 1 | .x == 2)) %>%
  rowSums() %>%
  mean()
moyenne_freq
```

### 3.Répartition des répondants selon le nombre de lieux fréquentés très régulièrement

#### Avec R natif

1.  On récupère les données `nb_tres_freq` qui sont le nombre de lieu d'achat très fréquenté par individu

2.  On transforme nos données en tableeau avec la fonction `table()`, puis on calcule la proportion de chaque variable (1 à 12) avec `prop.table()` que l'on va multiplier par cent pour avoir un pourcentage. On peutarrondir à deux chiffres après la virgule avec `round`

3.  On récupère le nom des dimenssions avec la fonction `dimnames()` et on récupère le nom du tableau avec `names` que l'on va réaffecter par son nouveau nom.

4.  On fait la mise en forme de notre tableau avec `kable()`

5.  **Créer le graphique à partir du tableau avec** `barplot()`

    -   Ajouter le titre et les noms des axes, et ajuster la limite de l’axe y selon la valeur maximale\
    -   Changer la couleur des barres et mettre en évidence la valeur maximale\
    -   Ajouter la valeur maximale au-dessus de la barre avec la fonction `text()`

```{r}

#(1)

head(nb_tres_freq)

#(2)

tb_nb_tres_freq_pourcent <- round(prop.table(table(nb_tres_freq))*100,2) 

#(3)

names(dimnames(tb_nb_tres_freq_pourcent)) <- "Nombre"

#(4)

print(tb_nb_tres_freq_pourcent)

#(5)

barplot(tb_nb_tres_freq_pourcent)

max_val <- max(tb_nb_tres_freq_pourcent)

barplot(tb_nb_tres_freq_pourcent, 
        main = "Répartition selon le nombre de lieux fréquentés très régulièrement",
        ylab = "pourcentage",
        xlab = "nombre de lieux très fréquenté",
        ylim = c(0,max_val+5))

coul <- rep("cyan3", length(tb_nb_tres_freq_pourcent))
max_id <- which.max(tb_nb_tres_freq_pourcent)
coul[max_id] <- "cyan1"


barplot(tb_nb_tres_freq_pourcent, 
        main = "Répartition selon le nombre de lieux fréquentés très régulièrement",
        ylab = "pourcentage",
        xlab = "nombre de lieux très fréquenté",
        ylim = c(0,max_val+5),
        col = coul)

barplot(tb_nb_tres_freq_pourcent, 
        main = "Répartition selon le nombre de lieux fréquentés très régulièrement",
        ylab = "pourcentage",
        xlab = "nombre de lieux très fréquenté",
        ylim = c(0,max_val+5),
        col = coul)
text(x = max_id, y = max_val, labels = max_val, pos = 3, cex = 1.3)
  
```

#### Avec usage de library

Voici la version avec usage de librairies R. Pour ce faire, nous utilsierons la librairie dplyr() (déjà vue et présentée lors de la question 1) pour générer les tableaux de contingences et de pourcentages des lieux fréquentés régulièrement par les consommateurs. Puis, nous nous appuyerons sur la fonction kable() de la librairie kableExtra() déjà rencontrée plus haut dans le rapport. Enfin, nous terminerons par une représentation graphique des lieux fréquentés régulièrement par les clients.

```{r}
# Tableau de contingence
df_nb_tres_freq <- data.frame(nb_tres_freq) %>%
  count(nb_tres_freq, name = "Effectif")

# Tableau de pourcentages 
dt_nb_tres_freq_pourcent <- data.frame(nb_tres_freq) %>%
  count(nb_tres_freq) %>%
  mutate(Pourcentage = round(n / sum(n) * 100, 2))

# Mise en forme du tableau des pourcentages
kable(dt_nb_tres_freq_pourcent) 

```

Voici, les différentes étapes à suivre pour construire un diagramme en barres avec la librairie ggplot2().

**Etape 1 : Renseigner le jeu de données**

La première des choses à faire est de rensigner sur quel jeu de données on travaille et le remplir dans l'argument ggplot(). Pour le moment, rien ne s'affiche et cela est tout à fait normal puisque nous n'avons pas encore précisé les variables pour construire le graphique et ni le type de graphique souhaité.

```{r}
ggplot(df_nb_tres_freq) #rien
```

**Etape 2 : Indiquer les variables retenues pour les axes des abscisses et des ordonnées**

Maintenant, il faut indiquer les variables retenues pour les axes des abscisses et de ordonnées dans l'argument aes(). Ici, il faut remplir *nb_tres_freq* pour x et *Effectif* pour y. Pour le moment, toujours rien ne s'affiche puisqu'il manque d'informer le type de graphique à dessiner.

```{r}
ggplot(df_nb_tres_freq)+aes(x=nb_tres_freq,y=Effectif) #rien
```

**Etape 3 : Indiquer les variables retenues pour les axes des abscisses et des ordonnées**

A l'aide de l'argument geom_bar() nous traçons le diagramme en barres. Par défaut, dans geom_bar(stat = "bin"), cela signifie que pour chaque valeur de x, les barres seront toutes dessinées à la même hauteur. De plus, le "bins" est incompatible avec des valeurs présentes sur l'axe des y, ce qui est notre cas ici. Il faut donc remplacer "bins" par le bon argument adéquate à savoir "identity". En effet, cela répond à notre besoin de représenter les hauteurs des barres qui prennent en compte les valeurs de y. Ainis, nous obtenons le premier diagramme en barres qui s'affiche à l'écran.

```{r}
ggplot(df_nb_tres_freq)+aes(x=nb_tres_freq,y=Effectif)+geom_bar(stat = "identity") # Bon
```

**Etape 4 : Personnalisation du graphique**

Le graphique de l'étape précédente est correcte mais pas "complet". En fonction des besoin de l'utilisateurs, il est tout à fait possible par exemple d'ajouter un titre, changer le nom des axes x et y de colorier les barres, de changer le fond d'écran et pleins d'autres choses encore. Il existe différentes manières de procéder. En ce lieu, nous proposerons une façon de personnaliser le diagramme en barres.

1.  Ajouter un titre : Avec labs(title = "")

2.  Changer le nom des axes x et y : Avec labs(x="", y ="")

3.  Colorier les barres : Avec geom_bar(fill = ""). On peut soit écrire le nom de couleurs en brut comme red, orange ou bien encore plus personnalisé le graphique en utilisant le code hexadéciamal des couleurs. Pour trouver les codes hexadéciamux des couleurs, on peut se rendre par exemple sur le site internet suivant : [**https://htmlcolorcodes.com/**]{.underline}

```{r}
ggplot(df_nb_tres_freq)+aes(x=nb_tres_freq,y=Effectif)+geom_bar(stat = "identity",fill = "#FF6666") + 
  labs(title = "Répartition des lieux très fréquentés par les consommateurs", 
       x = "Nombre de lieux très fréquentés",y = "Effectif")
```

### 4.Nombre de lieux fréquentés régulièrement (réponses 1/2/3/4) en moyenne

```{r}
dt_nb_moy <- data %>% # selection des bonnes colonnes
  select(Q6_1:Q6_12)

nb_rgl_freq <- rowSums(dt_nb_moy == 1 | dt_nb_moy == 2 | dt_nb_moy == 3 | dt_nb_moy == 4) # On compte le nombre de lieu régulièrement fréquenté par individu

print(paste("Les répondants fréquentent en moyenne ",round(mean(nb_rgl_freq),1)," lieux régulièrement (au moins une fois par mois)"))
```

### 5. Répartition des répondants selon le nombre de lieux fréquentés régulièrement

```{r}

df_nb_rgl_freq <- as.data.frame(table(nb_rgl_freq)) # On compte le nombre d'occurence par nb de lieux régulièrement fréquenté

dt_nb_rgl_freq_pourcent <- round(prop.table(table(nb_rgl_freq))*100,2) # On tranforme la fréquence en %

names(dimnames(dt_nb_rgl_freq_pourcent)) <- "Nombre de lieux régulièrement fréquenté"

kable(dt_nb_rgl_freq_pourcent)  #  mise en forme du tableau



ggplot(df_nb_rgl_freq, aes(x = nb_rgl_freq, y = Freq)) +
  geom_bar(stat = "identity")+
  labs(title = "fréquence par nombre lieux régulièrement fréquenté", x = "Nombre de lieux régulièrement fréquenté")

```

### 6.Pour ceux qui n’ont qu’1 lieu régulier (au moins une fois par mois): lequel ? part des répondants concernés

#### Avec R natif

(1) Création d'un vecteur qui sincrémente de 1 jusqu'à 12 via le symbole `:` 
(2) Concatener deux expressions avec `paste()` notez que `sep=` précise le séparateur entre les expressions
(3) Selection de colonnes en utilisant les crochets `[ligne, variables]`
(4) Faire la somme par ligne des cellules qui vérifie la ou les condition(s) dans `rowSums()`, 
En effet si la cellule vérifie alors elle vaut 1 sinon 0
(5) Realiser un filtre en spécifiant la colonne et la condition
(6) Arroundir la proportion calculé à deux chiffres après la virgule `round()`

```{r}
num_var <- 1:12
noms_var <- paste("Q6_", num_var, sep="")
df_vars <- data[,noms_var]
df_vars$freq <- rowSums(df_vars==1 | df_vars==2 | df_vars==3 | df_vars==4)
df_vars_filter <- df_vars[df_vars$freq==1,]
proportion <- (count(df_vars_filter)/count(df_vars))*100
arrondir_proportion <- round(proportion, 2)
```

#### Avec usage de library

(1) Sélection des variables spécifiques à la question : `select()`
(2) Appliquer à toutes les cellules des variables une ou des condition(s) : `across(everything(), ~ condition)`
(3) Pour chaque ligne ou individu faire la somme des cellules qui respectent le ou les conditions `rowSums()` 
puis la stocker dans une nouvelle variable qu'on ajoutera à la base de donnée
(4) Compter le nombre de français disponible dans la base via `count()` puis la stocker dans une 
variable intermédiaire qui sera definie à l'intérieur de `{{}}`. L'opérateur utilisé avant doit être "%T>%"
(5) Filtrer le jeu de donné avec `filter()` pour ne retenir que les individus ayant qu'un lieu régulier
(6) Utiliser summarise pour calculer la proportion et ne garder qu'elle


```{r}
library(magrittr) # %T>% 
(Frequence_regulier <- data %>% 
  select(Q6_1:Q6_12) %>%
  mutate(freq = rowSums(across(everything(), ~ .x==1 | .x==2 | .x==3 | .x==4))) %T>%
  {{nombre_francais <<- count(.)}} %>%
  filter(freq==1) %>%
  summarise(round((count(.)/nombre_francais)*100,2)))
```

### 7.Pour chaque lieu unique fréquenté quel est leur profil ? (socio + motivations

#### Avec R natif

(1) Création des $12$ jeux de données par lieu d'achat filtrés par variables d'intérêt pour le profil sociologique ainsi que pour les motivations grâce à la fonction `subset()`
(2) Développement d'une fonction avec `function()` pour automatiser les tâches suivantes. Pour chaque lieu d'achat, affichons la valeur la plus fréquente de chaque variable `avec which.max()` et de `names()`, modifions le nom de la colonne avec `names()` et attribuons un nom à la colonne (contenant le libellé des questions) avec `rownames_to_column()` qui n'en possède pas par défaut.
(3) Application de la fonction sur tous les lieux d'achat
(4) Afficher les tableaux avec `print()`

```{r}
# (1) 

data_hypermarche <- subset(data1,select=-c(1,3,5,7:16,18:46,58:400)) 
data_Hard_discount <- subset(data1,select=-c(1,3,5,7:16,17,19:46,58:400)) 
data_Epiceries_inde <- subset(data1,select=-c(1,3,5,7:16,17,18,20:46,58:400)) 
data_magains_surgele <- subset(data1,select=-c(1,3,5,7:19,21:46,58:400)) 
data_Bio <- subset(data1,select=-c(1,3,5,7:20,22:46,58:400)) 
data_Marche <- subset(data1,select=-c(1,3,5,7:21,23:46,58:400)) 
data_agriculteur <- subset(data1,select=-c(1,3,5,7:22,24:46,58:400))
data_Paniers_ligne <- subset(data1,select=-c(1,3,5,7:23,25:46,58:400))
data_artisans_commerce_spe <- subset(data1,select=-c(1,3,5,7:24,26:46,58:400))
data_Epicerie_participative <- subset(data1,select=-c(1,3,5,7:25,27:46,58:400))
data_Magasin_alimentaire_spe_vrac <- subset(data1,select=-c(1,3,5,7:26,28:46,58:400))
data_Magasin_aide_alimentaire <- subset(data1,select=-c(1,3,5,7:27,29:46,58:400))


noms_colonnes <- c("Q1", "recode_age", "recode_csp", "Hypermarché", "Q10", "Q11", "Q12", "Q13", "Q14", "Q15", "Q16", "Q17", "Q18", "Q19", "Q20", "Q235",  "Q236", "Q237","Q238", "Q239", "Q240")


mode_data <- function(data) {
  res <- list()
  for (col in noms_colonnes) {
    res[[col]] <- names(which.max(table(data[[col]])))
  }
  res <- as.data.frame(do.call(rbind, res))
  names(res) <- c("Valeur la plus fréquente")
  res <- rownames_to_column(res, var = "Question posée")
  return(res)
}

# (3)
modes_hypermarche <- mode_data(data_hypermarche)
modes_Hard_discount <- mode_data(data_Hard_discount)
modes_Epiceries_inde <- mode_data(data_Epiceries_inde)
modes_magains_surgele <- mode_data(data_magains_surgele)
modes_Bio <- mode_data(data_Bio)
modes_Marche <- mode_data(data_Marche )
modes_agriculteur <- mode_data(data_agriculteur)
modes_Paniers_ligne <- mode_data(data_Paniers_ligne)
modes_artisans_commerce_spe <- mode_data(data_artisans_commerce_spe)
modes_Epicerie_participative <- mode_data(data_Epicerie_participative)
modes_Magasin_alimentaire_spe_vrac <- mode_data(data_Magasin_alimentaire_spe_vrac)
modes_Magasin_aide_alimentaire <- mode_data(data_Magasin_aide_alimentaire)

# (4)

print(modes_hypermarche)
print(modes_Hard_discount)
print(modes_Epiceries_inde)
print(modes_magains_surgele)
print(modes_Bio)
print(modes_Marche)
print(modes_agriculteur)
print(modes_Paniers_ligne)
print(modes_artisans_commerce_spe)
print(modes_Epicerie_participative)
print(modes_Magasin_alimentaire_spe_vrac)
print(modes_Magasin_aide_alimentaire)
```

#### Avec usage de library

(1) Creation des sous-ensembles avec `dplyr::select()`. La notation `::` permet de faire appel uniquement à une fonction spécifique de la librairie au lieu de la télécharger entièrement avec l'ensemble des fonctions contenues à l'intérieur.
(2) Création d'une fonction pour calculer la valeur la plus fréquente
    (1) `lapply()` : applique une fonction à chaque élément d’une liste (ici, chaque nom de colonne dans noms_colonnes) et retourne une liste des résultats.
    (2) `%in%` : teste si un élément (ici, le nom de colonne) appartient à un vecteur (ici, les noms des colonnes du data).
    (3) `table()` : calcule la fréquence d'apparition de chaque valeur dans une variable (colonne).
    (4) `which.max()` : retourne l’indice de la valeur maximale (utilisé ici pour trouver la modalité la plus fréquente).
    (5) `names()` : ici, permet d’extraire le nom (valeur) associée à la fréquence maximale dans la table.
    (6) `do.call(rbind, ...)` : empile les résultats de la liste (res) en un tableau (data.frame) ligne par ligne.
    (7) `as.data.frame()` : convertit l'objet obtenu en un data.frame.
    (8) `names() (assignation)` : renomme la colonne du data frame avec le nom "Valeur la plus fréquente".
    (9) `tibble::rownames_to_column()` : transforme les noms de lignes en une vraie colonne, ici appelée "Question posée".
    (10) `kable` : permet de mettre en forme le tableau
(3) Application de la fonction sur tous les lieux d'achat
(4) Afficher les tableaux avec `print()`

```{r}
library(dplyr)
library(tibble)

# (1)

data_hypermarche <- data1 %>% select(-c(1,3,5,7:16,18:46,58:400))
data_Hard_discount <- data1 %>% select(-c(1,3,5,7:16,17,19:46,58:400))
data_Epiceries_inde <- data1 %>% select(-c(1,3,5,7:16,17,18,20:46,58:400))
data_magains_surgele <- data1 %>% select(-c(1,3,5,7:19,21:46,58:400))
data_Bio <- data1 %>% select(-c(1,3,5,7:20,22:46,58:400))
data_Marche <- data1 %>% select(-c(1,3,5,7:21,23:46,58:400))
data_agriculteur <- data1 %>% select(-c(1,3,5,7:22,24:46,58:400))
data_Paniers_ligne <- data1 %>% select(-c(1,3,5,7:23,25:46,58:400))
data_artisans_commerce_spe <- data1 %>% select(-c(1,3,5,7:24,26:46,58:400))
data_Epicerie_participative <- data1 %>% select(-c(1,3,5,7:25,27:46,58:400))
data_Magasin_alimentaire_spe_vrac <- data1 %>% select(-c(1,3,5,7:26,28:46,58:400))
data_Magasin_aide_alimentaire <- data1 %>% select(-c(1,3,5,7:27,29:46,58:400))

noms_colonnes <- c("Q1", "recode_age", "recode_csp", "Hypermarché", "Q10", "Q11", "Q12", "Q13", "Q14", "Q15", "Q16", "Q17", "Q18", "Q19", "Q20", "Q235",  "Q236", "Q237","Q238", "Q239", "Q240")

# (2) 
mode_data <- function(data) {
  res <- lapply(noms_colonnes, function(col) {
    if (col %in% colnames(data)) {
      val <- names(which.max(table(data[[col]])))
    } else {
      val <- NA
    }
    return(val)
  })
  res <- as.data.frame(do.call(rbind, res))
  names(res) <- "Valeur la plus fréquente"
  res <- tibble::rownames_to_column(res, var = "Question posée")
  res <- kable(res)
  return(res)
}

# (3)
modes_hypermarche <- mode_data(data_hypermarche)
modes_Hard_discount <- mode_data(data_Hard_discount)
modes_Epiceries_inde <- mode_data(data_Epiceries_inde)
modes_magains_surgele <- mode_data(data_magains_surgele)
modes_Bio <- mode_data(data_Bio)
modes_Marche <- mode_data(data_Marche)
modes_agriculteur <- mode_data(data_agriculteur)
modes_Paniers_ligne <- mode_data(data_Paniers_ligne)
modes_artisans_commerce_spe <- mode_data(data_artisans_commerce_spe)
modes_Epicerie_participative <- mode_data(data_Epicerie_participative)
modes_Magasin_alimentaire_spe_vrac <- mode_data(data_Magasin_alimentaire_spe_vrac)
modes_Magasin_aide_alimentaire <- mode_data(data_Magasin_aide_alimentaire)

# (4)
print(modes_hypermarche)
print(modes_Hard_discount)
print(modes_Epiceries_inde)
print(modes_magains_surgele)
print(modes_Bio)
print(modes_Marche)
print(modes_agriculteur)
print(modes_Paniers_ligne)
print(modes_artisans_commerce_spe)
print(modes_Epicerie_participative)
print(modes_Magasin_alimentaire_spe_vrac)
print(modes_Magasin_aide_alimentaire)

```
### 8.Créer un sous échantillon appelé les acheteurs très réguliers de produits locaux et ou en circuits courts

#### Avec R natif

1.  Dans un premier vecteur on met les colonnes que l'on va vérifier.

2.  À l'aide de la fonction `apply()` je vérifie par ligne s'il y a au moins une valeur égal à 1 ou 2 sur une des colonnes à tester.

3.  On sélectionne les lignes colonnes que l'on souhaite et on empile les colonnes de notre nouveau data frame df_cc dans df_cc_comp avec la fonction `stack()`.

4.  On fait un tableau de fréquence avec `table()`en fonction des catégories croisée. (valeur de 1 à 6 croisé aux questions). Et on change le nom des colonnes avec `dimnames()`.

5.  On calcule la proportion par question à l'aide de la fonction `prop.table()` et de largumentt 2 dans margin. On calcule le pourcentage en multipliant par 100 et on arrondi le résultat avec `round()`.

6.  On calcule le pourcentage des individus qui achètent très régulièrement en circuit court en calculant et le nombre d'individus sur le nombre d'individus total que l'on multiplie par 100 avec `sum()` et `nrow()`.

```{r}

#1

col_a_tester <- c("Q27", "Q35", "Q43", "Q50", "Q59", "Q67", "Q81", "Q89", "Q97", "Q104", "Q111",
                  "Q118", "Q125", "Q133", "Q142", "Q149", "Q157", "Q165", "Q173", "Q181", "Q189",
                  "Q200", "Q208", "Q216", "Q224")

#2

lignes_a_garder <- apply(data[, col_a_tester], MARGIN = 1, function(x) any(x == 1 | x == 2))

#3

df_cc <- data[lignes_a_garder,c("Q1","recode_age","recode_csp")]

df_cc_comp <- stack(df_cc)

#4

tb_cc <- table(df_cc_comp)
dimnames(tb_cc)[[2]] <- c("Sexe", "Tranche d'âge","CSP")

#5

tb_cc_freq <- round(prop.table(tb_cc, margin = 2)*100, 2)

tb_cc_freq

#6

print(paste("Il y a",round(sum(lignes_a_garder, na.rm = T)/nrow(data)*100),"pourcent des acheteurs qui achètent en très régulièrement en circuit court"))

```

#### Avec usage de library

-   Pour chaque fonction utiliser on utilise `%>%` de dplyr pour incrémenter chaque fonction de manière fluide.

1.  On calcule le filtre des lignes qui nous intéresse avec `filter`.
2.  On sélectionne les colonnes qui nous intéressent avec la fonction `select`.
3.  On fait une mise au format long du notre dataframe en deux colonnes Questions et Réponses à l'aide de la fonction `pivot_longer`.
4.  Avec la `table()` on calcule les fréquences croisées et on calcule la proportion par ligne avec `prop.table()`.
5.  On termine avec une mise en forme avec `kable()` pour un tableau propre que l'on peut modifier de différentes manières.
6.  On calcule le pourcentage des individus qui achètent très régulièrement en circuit court en calculant et le nombre d'individus sur le nombre d'individus total que l'on multiplie par 100 avec `sum()` et `nrow()`.

```{r}
#1

df_cc <- data %>% filter(rowSums(across(all_of(col_a_tester), ~ .x %in% c(1, 2))) >= 1) %>% 
  
#2
  
  select(Q1,recode_age,recode_csp) %>% 
  
#3 
  
  pivot_longer(cols = everything(),
               names_to = "Questions",
               values_to = "Réponses") %>% 

#4
  
  table() %>% prop.table(margin = 1)*100
dimnames(df_cc)[[1]] <- c("Sexe", "Tranche d'âge","CSP")

#5

kable(round(df_cc, 2), caption = "Répartition des acheteurs réguliers de produits locaux et ou en circuits courts (%)")%>% 
  kable_styling(latex_options = "striped")

#6

print(paste("Il y a",round(sum(lignes_a_garder, na.rm = T)/nrow(data)*100),"pourcent des acheteurs qui achètent en très régulièrement en circuit court"))

```

### 9.Créer un sous échantillon appelé les acheteurs réguliers de produits locaux et ou en circuits courts

#### Avec R natif

1.  Dans un premier vecteur on met les colonnes que l'on va vérifier.

2.  À l'aide de la fonction `apply()` je vérifie par ligne s'il y a au moins une valeur égal à 3 ou 4 sur une des colonnes à tester.

3.  On sélectionne les lignes colonnes que l'on souhaite et on empile les colonnes de notre nouveau data frame df_cc dans df_cc_comp avec la fonction `stack()`.

4.  On fait un tableau de fréquence avec `table()`en fonction des catégories croisée. (valeur de 1 à 6 croisé aux questions). Et on change le nom des colonnes avec `dimnames()`.

5.  On calcule la proportion par question à l'aide de la fonction `prop.table()` et de largumentt 2 dans margin. On calcule le pourcentage en multipliant par 100 et on arrondi le résultat avec `round()`.

6.  On calcule le pourcentage des individus qui achètent régulièrement en circuit court en calculant et le nombre d'individus sur le nombre d'individus total que l'on multiplie par 100 avec `sum()` et `nrow()`.

```{r}

#1

col_a_tester <- c("Q27", "Q35", "Q43", "Q50", "Q59", "Q67", "Q81", "Q89", "Q97", "Q104", "Q111",
                  "Q118", "Q125", "Q133", "Q142", "Q149", "Q157", "Q165", "Q173", "Q181", "Q189",
                  "Q200", "Q208", "Q216", "Q224")

#2

lignes_a_garder <- apply(data[, col_a_tester], MARGIN = 1, function(x) any(x == 3 | x == 4))

#3

df_cc <- data[lignes_a_garder,c("Q1","recode_age","recode_csp")]

df_cc_comp <- stack(df_cc)

#4

tb_cc <- table(df_cc_comp)
dimnames(tb_cc)[[2]] <- c("Sexe", "Tranche d'âge","CSP")

#5

tb_cc_freq <- round(prop.table(tb_cc, margin = 2)*100, 2)

#6

print(paste("Il y a",round(sum(lignes_a_garder, na.rm = T)/nrow(data)*100),"pourcent des acheteurs qui achètent en très régulièrement en circuit court"))

tb_cc_freq

```

#### Avec usage de library

-   Pour chaque fonction utiliser on utilise `%>%` de dplyr pour incrémenter chaque fonction de manière fluide.

1.  On calcule le filtre des lignes qui nous intéresse avec `filter`.
2.  On sélectionne les colonnes qui nous intéressent avec la fonction `select`.
3.  On fait une mise au format long du notre dataframe en deux colonnes Questions et Réponses à l'aide de la fonction `pivot_longer`.
4.  Avec la `table()` on calcule les fréquences croisées et on calcule la proportion par ligne avec `prop.table()`. Et on change le nom des colonnes avec `dimnames`.
5.  On termine avec une mise en forme avec `kable()` pour un tableau propre que l'on peut modifier de différentes manières.
6.  On calcule le pourcentage des individus qui achètent régulièrement en circuit court en calculant et le nombre d'individus sur le nombre d'individus total que l'on multiplie par 100 avec `sum()` et `nrow()`.

```{r}
#1

df_cc <- data %>% filter(rowSums(across(all_of(col_a_tester), ~ .x %in% c(3, 4))) >= 1) %>% 
  
#2
  
  select(Q1,recode_age,recode_csp) %>% 
  
#3 
  
  pivot_longer(cols = everything(),
               names_to = "Questions",
               values_to = "Réponses") %>% 

#4
  
  table() %>% prop.table(margin = 1)*100
dimnames(df_cc)[[1]] <- c("Sexe", "Tranche d'âge","CSP")

#5

kable(round(df_cc, 2), caption = "Répartition des acheteurs réguliers de produits locaux et ou en circuits courts (%)")%>% 
  kable_styling(latex_options = "striped")

#6

print(paste("Il y a",round(sum(lignes_a_garder, na.rm = T)/nrow(data)*100),"pourcent des acheteurs qui achètent en très régulièrement en circuit court"))
```

### 10. Sous échantillon appelé les acheteurs très réguliers de produits locaux et ou en circuits courts achetant directement aux producteurs
#### Avec R natif

1. Identifier pour chaque question ceux ou celles ayant repondu 1 ou 2,
2. Selectionner le jeu de données respectant la condition précédente,
3. Compter le nombre de lignes obtenue grâce à la condition `nrow()` puis diviser par le nombre total d'individu,
4. Repérer le numero de la question puis realiser un tableau descriptif des modalités de la question avec `table()`,
5. Ajouter les totaux par lignes ou colonnes avec `addmargins()` en spécifiant 2 pour les lignes et 1 pour les colonnes.

```{r}
condition <- data$Q27 %in% c(1, 2) | data$Q35 %in% c(1, 2) | data$Q43 %in% c(1, 2) | data$Q50 %in% c(1, 2) | data$Q59 %in% c(1, 2) # Conditionn de la question
sous_echantillon <- data[condition, ]
pourcentage <- nrow(sous_echantillon)/nrow(data) * 100
arrondir_pourcentage <- round(pourcentage,2) # Arrondir le pourcentage à 2 chiffres après la virgule
arrondir_pourcentage

table(sous_echantillon$Q2) # selon l'âge
table(sous_echantillon$Q1) # selon le genre
table(sous_echantillon$Q3) # selon la CSP
table(cut(sous_echantillon$Q8, breaks = c(0, 199, 399, 599, 799, 999, 1499, Inf),
                    labels = c("[0 – 199[", "[200 – 399[", "[400 – 599[", "[600 – 799[", "[800 – 999[", "[1000 – 1499[", "[1500 et plus["),
                    right = FALSE))
table(sous_echantillon$Q240) # selon le niveau de diplôme
# table(sous_echantillon$Q5_taille) # selon la taille de l'agglomeration
table(sous_echantillon$Q236) # nb d'enfants
addmargins(table(sous_echantillon$Q235, sous_echantillon$Q236), 2)  # taille du foyer
```
#### Avec usage de library

1. Ajouter une variable à la base de données qui prend la valeur 1 si la condition est respecté 0 sinon
2. Selectionner uniquement que les individus qui respectent le filtre
3. utiliser `tbl_summary()` pour réaliser directement un tableau pour chaque variable ajouté

```{r}
filter_data <- data %>%
  mutate(condition = ifelse((Q27 %in% c(1,2) | Q35 %in% c(1,2) | Q43 %in% c(1,2) | Q50 %in% c(1,2) |  Q59 %in% c(1,2)),1,0)) %>%
  filter(condition==1)

# le pourcentage
pourcentage_lib <-  filter_data %T>%
  {{nombre_individu <<- nrow(data)}} %>%
  summarise(prop = n()) %>%
  pull()/nombre_individu*100

pourcentage_lib

filter_data %>%
  tbl_summary(include = c(Q1, Q2, Q8, Q240, Q236, Q235))
```

### 11 Sous échantillon appelé les acheteurs réguliers de produits locaux et ou en circuits courts achetant directement aux producteurs
#### Avec R natif
```{r}
condition <- data$Q27 %in% c(3, 4) | data$Q35 %in% c(3, 4) | data$Q43 %in% c(3, 4) | data$Q50 %in% c(3, 4) | data$Q59 %in% c(3, 4) # Conditionn de la question
sous_echantillon <- data[condition, ]
pourcentage <- nrow(sous_echantillon)/nrow(data) * 100
arrondir_pourcentage <- round(pourcentage,2) # Arrondir le pourcentage à 2 chiffres après la virgule
arrondir_pourcentage

table(sous_echantillon$Q2) # selon l'âge
table(sous_echantillon$Q1) # selon le genre
table(sous_echantillon$Q3) # selon la CSP
table(cut(sous_echantillon$Q8, breaks = c(0, 199, 399, 599, 799, 999, 1499, Inf),
                    labels = c("[0 – 199[", "[200 – 399[", "[400 – 599[", "[600 – 799[", "[800 – 999[", "[1000 – 1499[", "[1500 et plus["),
                    right = FALSE))
table(sous_echantillon$Q240) # selon le niveau de diplôme
# table(sous_echantillon$Q5_taille) # selon la taille de l'agglomeration
table(sous_echantillon$Q236) # nb d'enfants
addmargins(table(sous_echantillon$Q235, sous_echantillon$Q236), 2)  # taille du foyer
```
#### Avec usage de library

```{r}
filter_data <- data %>%
  mutate(condition = ifelse((Q27 %in% c(3,4) | Q35 %in% c(3,4) | Q43 %in% c(3,4) | Q50 %in% c(3,4) |  Q59 %in% c(3,4)),1,0)) %>%
  filter(condition==1)

# le pourcentage
pourcentage_lib <-  filter_data %T>%
  {{nombre_individu <<- nrow(data)}} %>%
  summarise(prop = n()) %>%
  pull()/nombre_individu*100

pourcentage_lib

filter_data %>%
  tbl_summary(include = c(Q1, Q2, Q8, Q240, Q236, Q235))
```

### 13. Quelles combinaisons de lieux fréquentés régulièrement possibles (fréquentés au moins une fois par mois)

#### Avec R natif

(1) Sélection des colonnes des lieux d'achat
(2) Calcul du % de fréquentation (modalités 1 à 4) pour chaque lieu. Utilisation de `sapply()` pour appliquer l'opération du calcul de pourcentage sur les colonnes de lieux d'achat.
(3) Trier du lieu le plus fréquenté au moins fréquenté grâce à `sort()` et l'agument `decreasing = TRUE`
(4) Sélection des 10 lieux les plus fréquentés avec `head()`
(5) Affichage de la table des 10 lieux d'achat les plus fréquentés avec `print()`

```{r}
# (1) 
lieux_data <- data[17:28]

# (2) 
freq_percent <- sapply(lieux_data, function(col) {
  sum(col %in% 1:4, na.rm = TRUE) / sum(!is.na(col)) * 100
})

# (3) 
freq_sorted <- sort(freq_percent, decreasing = TRUE)

# (4)
top10_freq <- head(freq_sorted, 10)

# (5) 
print(round(top10_freq, 1))

```

#### Avec usage de library

(1) Création des la table des 10 lieux les plus fréquentés
    (1) On sélectionne les colonnes (lieux d'achat) avec `select()`.
    (2) On crée une table au format long avec `pivot_longer()`
    (3) On regroupe par lieu d'achat avec `group_by()`
    (4) On calcule les pourcentage avec `summarise()` en s'assurant de ne pas comptabiliser les valeurs manquantes `!is.na()`. A noter que le `!` correspond à l'évènement contraire.
    (5) On trie avec `arrange()` par ordre décroissant à l'aide de l'argument `desc()`
    (6) On ne retient que les 10 premiers lieux les plus fréquentés avec `slice_head()`
    (7) On ajoute dans le tableau final, la colonne des pourcentages des lieux fréquéntés avec `mutate()`
(2) Affichage de la table des 10 lieux d'achat les plus fréquentés de façon élégante avec `kable()`

```{r}
# (1) 
top10_freq <- data %>%
  select(17:28) %>%
  pivot_longer(cols = everything(), names_to = "lieu", values_to = "frequence") %>%
  filter(frequence %in% 1:4) %>%
  group_by(lieu) %>%
  summarise(
    nb = n(),
    total = sum(!is.na(data[[unique(lieu)]])),
    pourcentage = nb / total * 100
  ) %>%
  arrange(desc(pourcentage)) %>%
  slice_head(n = 10) %>%
  mutate(pourcentage = round(pourcentage, 1))

# (2)
kable(top10_freq) %>% 
  kable_styling(latex_options = "striped")

```

### 14. Pour chaque combinaison, quel profil de répondants ? Voir quelles sont les variables explicatives de cette nouvelle variable "combinaison"

#### Avec R natif

(1) Création des 12 jeux de données par lieu d'achat. À partir du jeu de données principal data1, nous avons extrait 12 sous-jeux de données, chacun correspondant à un type de lieu d’achat (ex. : hypermarché, hard-discount, épicerie indépendante, etc.). Ces sous-échantillons sont créés à l’aide de la fonction `subset()`, en filtrant les colonnes correspondant à des variables d’intérêt sociologique (sexe, âge, CSP, taille de l’agglomération, budget, etc.) ainsi qu'à une variable de motivation propre à chaque type de lieu.

(2) Développement d'une fonction analyser_sous_echantillon(). Cette fonction est conçue pour automatiser l’analyse descriptive d’un sous-échantillon. Elle effectue les tâches suivantes :

    (1) Calcule le nombre d’individus dans le sous-échantillon, et son pourcentage par rapport à l’échantillon total.

    (2) Affiche la répartition des individus selon plusieurs variables socio-démographiques

        (1) Genre (Q1)

        (2) Âge (recode_age)

        (3) CSP (recode_csp)

        (4) Taille d’agglomération (Q5_taille)

        (5) Budget alimentaire (Q8)

        (6) Nombre d’enfants (Q236)

        (7) Taille du foyer (somme de Q235 et Q236)

        (8) Niveau de diplôme (Q240)

(3) Application de la fonction sur les 12 sous-échantillons. La fonction est ensuite appliquée à chacun des sous-jeux de données pour obtenir, de manière systématique, le profil des consommateurs selon le lieu d'achat.

```{r}
# (1) 
data_hypermarche <- subset(data1,select=c(2,4,6,11,17,33,401,402,406)) 
data_Hard_discount <- subset(data1,select=c(2,4,6,11,18,33,401,402,406))
data_Epiceries_inde <- subset(data1,select=c(2,4,6,11,19,33,401,402,406)) 
data_magains_surgele <- subset(data1,select=c(2,4,6,11,20,33,401,402,406)) 
data_Bio <- subset(data1,select=c(2,4,6,11,21,33,401,402,406)) 
data_Marche <- subset(data1,select=c(2,4,6,11,22,33,401,402,406)) 
data_agriculteur <- subset(data1,select=c(2,4,6,11,23,33,401,402,406))
data_Paniers_ligne <- subset(data1,select=c(2,4,6,11,24,33,401,402,406))
data_artisans_commerce_spe <- subset(data1,select=c(2,4,6,11,25,33,401,402,406))
data_Epicerie_participative <- subset(data1,select=c(2,4,6,11,26,33,401,402,406))
data_Magasin_alimentaire_spe_vrac <- subset(data1,select=c(2,4,6,11,27,33,401,402,406))
data_Magasin_aide_alimentaire <- subset(data1,select=c(2,4,6,11,28,33,401,402,406))

# (2) 

analyser_sous_echantillon <- function(data_total, data_sub) {
  total_n <- nrow(data_total)
  sub_n <- nrow(data_sub)
  
  cat("Nombre de répondants dans le sous-échantillon :", sub_n, "\n")
  cat("Pourcentage par rapport à l'échantillon total :", round(100 * sub_n / total_n, 2), "%\n\n")
  
  cat("Répartition selon le genre (Q1) :\n")
  print(table(data_sub[, "Q1"], useNA = "ifany"))
  cat("\n")
  
  cat("Répartition selon l'âge (recode_age) :\n")
  print(table(data_sub[, "recode_age"], useNA = "ifany"))
  cat("\n")
  
  cat("Répartition selon la CSP (recode_csp) :\n")
  print(table(data_sub[, "recode_csp"], useNA = "ifany"))
  cat("\n")
  
  cat("Répartition selon la taille de l'agglomération (Q5_taille) :\n")
  print(table(data_sub[, "Q5_taille"], useNA = "ifany"))
  cat("\n")
  
  cat("Répartition selon le budget alimentaire (Q8) :\n")
  print(table(data_sub[, "Q8"], useNA = "ifany"))
  cat("\n")
  
  cat("Répartition selon le nombre d'enfants (Q236) :\n")
  print(table(data_sub[, "Q236"], useNA = "ifany"))
  cat("\n")
  
  cat("Répartition selon la taille du foyer (Q235 + Q236) :\n")
  taille_foyer <- data_sub[, "Q235"] + data_sub[, "Q236"]
  print(table(taille_foyer, useNA = "ifany"))
  cat("\n")
  
  cat("Répartition selon le niveau de diplôme (Q240) :\n")
  print(table(data_sub[, "Q240"], useNA = "ifany"))
  cat("\n")
}

# (3) 
analyser_sous_echantillon(data1, data_hypermarche)
analyser_sous_echantillon(data1, data_Hard_discount)
analyser_sous_echantillon(data1, data_Epiceries_inde)
analyser_sous_echantillon(data1, data_magains_surgele)
analyser_sous_echantillon(data1, data_Bio)
analyser_sous_echantillon(data1, data_Marche)
analyser_sous_echantillon(data1, data_agriculteur)
analyser_sous_echantillon(data1, data_Paniers_ligne)
analyser_sous_echantillon(data1, data_artisans_commerce_spe)
analyser_sous_echantillon(data1, data_Epicerie_participative)
analyser_sous_echantillon(data1, data_Magasin_alimentaire_spe_vrac)
analyser_sous_echantillon(data1, data_Magasin_aide_alimentaire)

```

#### Avec usage de library

(1) Création des 12 jeux de données par lieu d'achat. Chaque sous-échantillon est généré à partir du jeu de données principal data1, en sélectionnant les colonnes pertinentes (variables socio-démographiques + variable spécifique au lieu d’achat). Cette opération est effectuée à l’aide de la fonction `select()` du package dplyr, qui permet de ne conserver que certaines colonnes dans un tableau de données. La syntaxe `%>%`(pipe) est issue du package magrittr et permet d’enchaîner les opérations de manière lisible. Elle se lit comme “puis” : on applique une fonction à l’objet qui précède. Ce que fait `select() `: elle extrait uniquement les colonnes dont les indices sont spécifiés, ici les variables sociologiques et celles propres au type de lieu.

(2) Développement d'une fonction `analyser_sous_echantillon_dplyr()`. Cette fonction, développée avec dplyr, automatise l’analyse descriptive des sous-échantillons et calcule:

    (1) Le nombre d’individus et leur proportion dans l’échantillon total

    (2) La distribution des individus selon des variables clés

    (3) La taille du foyer, calculée dynamiquement. 
    Fonction imbriquée `afficher_tableau()`. Cette fonction interne permet d’afficher les effectifs et pourcentages d’une variable donnée. Elle s’appuie sur :
      1.  `group_by()` : regroupe les données selon les modalités de la variable ;
      2.  `summarise(N = n())` : calcule le nombre d’observations (n()) par modalité ;
      3.  `mutate()`: ajoute une colonne avec les pourcentages. 
  <br>

      Le **`.data[[variable]]`** : syntaxe non standard utilisée pour faire du "programmation fonctionnelle" avec des noms de variables passés dynamiquement dans une fonction. La fonction `afficher_tableau()` est ensuite appelée pour chaque variable d’intérêt. Puis, une nouvelle colonne `taille_foyer` est créée avec `mutate()` en faisant la somme de deux variables (`Q235` et `Q236`), puis les données sont regroupées et résumées comme précédemment.

(3) Application de la fonction sur les 12 sous-échantillons La fonction est utilisée pour analyser tous les types de lieux d’achat. Cela permet d'obtenir, pour chaque canal, un tableau clair et formaté des caractéristiques sociodémographiques des usagers.

```{r}
# (1)

data_hypermarche <- data1 %>% select(2, 4, 6, 11, 17, 33, 401, 402, 406)
data_Hard_discount <- data1 %>% select(2, 4, 6, 11, 18, 33, 401, 402, 406)
data_Epiceries_inde <- data1 %>% select(2, 4, 6, 11, 19, 33, 401, 402, 406)
data_magains_surgele <- data1 %>% select(2, 4, 6, 11, 20, 33, 401, 402, 406)
data_Bio <- data1 %>% select(2, 4, 6, 11, 21, 33, 401, 402, 406)
data_Marche <- data1 %>% select(2, 4, 6, 11, 22, 33, 401, 402, 406)
data_agriculteur <- data1 %>% select(2, 4, 6, 11, 23, 33, 401, 402, 406)
data_Paniers_ligne <- data1 %>% select(2, 4, 6, 11, 24, 33, 401, 402, 406)
data_artisans_commerce_spe <- data1 %>% select(2, 4, 6, 11, 25, 33, 401, 402, 406)
data_Epicerie_participative <- data1 %>% select(2, 4, 6, 11, 26, 33, 401, 402, 406)
data_Magasin_alimentaire_spe_vrac <- data1 %>% select(2, 4, 6, 11, 27, 33, 401, 402, 406)
data_Magasin_aide_alimentaire <- data1 %>% select(2, 4, 6, 11, 28, 33, 401, 402, 406)

# (2)

analyser_sous_echantillon_dplyr <- function(data_total, data_sub) {
  total_n <- nrow(data_total)
  sub_n <- nrow(data_sub)
  
  cat("Nombre de répondants dans le sous-échantillon :", sub_n, "\n")
  cat("Pourcentage par rapport à l'échantillon total :", round(100 * sub_n / total_n, 2), "%\n\n")
  
  afficher_tableau <- function(data, variable, nom_variable) {
    cat(paste("Répartition selon", nom_variable, ":\n"))
    print(data %>%
            group_by(.data[[variable]]) %>%
            summarise(N = n()) %>%
            mutate(Percent = round(100 * N / sum(N), 2)))
    cat("\n")
  }

  afficher_tableau(data_sub, "Q1", "le genre (Q1)")
  afficher_tableau(data_sub, "recode_age", "l'âge (recode_age)")
  afficher_tableau(data_sub, "recode_csp", "la CSP (recode_csp)")
  afficher_tableau(data_sub, "Q5_taille", "la taille de l'agglomération (Q5_taille)")
  afficher_tableau(data_sub, "Q8", "le budget alimentaire (Q8)")
  afficher_tableau(data_sub, "Q236", "le nombre d'enfants (Q236)")
  
  cat("Répartition selon la taille du foyer (Q235 + Q236) :\n")
  data_sub %>%
    mutate(taille_foyer = Q235 + Q236) %>%
    group_by(taille_foyer) %>%
    summarise(N = n()) %>%
    mutate(Percent = round(100 * N / sum(N), 2)) %>%
    print()
  cat("\n")
  
  afficher_tableau(data_sub, "Q240", "le niveau de diplôme (Q240)")
}

# (3)
analyser_sous_echantillon_dplyr(data1, data_hypermarche)
analyser_sous_echantillon_dplyr(data1, data_Hard_discount)
analyser_sous_echantillon_dplyr(data1, data_Epiceries_inde)
analyser_sous_echantillon_dplyr(data1, data_magains_surgele)
analyser_sous_echantillon_dplyr(data1, data_Bio)
analyser_sous_echantillon_dplyr(data1, data_Marche)
analyser_sous_echantillon_dplyr(data1, data_agriculteur)
analyser_sous_echantillon_dplyr(data1, data_Paniers_ligne)
analyser_sous_echantillon_dplyr(data1, data_artisans_commerce_spe)
analyser_sous_echantillon_dplyr(data1, data_Epicerie_participative)
analyser_sous_echantillon_dplyr(data1, data_Magasin_alimentaire_spe_vrac)
analyser_sous_echantillon_dplyr(data1, data_Magasin_aide_alimentaire)

```


### 15.Budget moyen

#### Avec R natif

1.  On selectionne la colonne Q8 avec `$` et on fait la moyenne avec la fonction `mean()`.
2.  On affiche le résultat arrondi avec `round()` que l'on colle avec un texte avec la fonction `paste()`

```{r}

#1

moy_budget <- mean(data$Q8, na.rm = T)

#2

print(paste("Le budget alimentaire moyen est de",round(moy_budget),"euros"))
```

### 16. Budget médian
#### Avec R natif
1. On selectionne la colonne Q8 avec `$` et on fait la médiane avec la fonction `median()`.

```{r}
median_budget <- median(data$Q8)
median_budget
```
#### Avec usage de library

```{r}
median_budget2 <- data %>%
summarise(mediane = median(Q8))
median_budget2
```

### 18.Budget moyen consacré a chaque modalité de lieu

#### Avec R natif

1.  On sélectionne les colonnes Q9_1 à Q9_13. On utilise `paste()` pour simplifier les noms de colonne.
2.  On remplace les valeurs manquantes 0 que l'on repère avec `is.na()` avec `replace()`.
3.  On calcule les moyennes par colonne avec `colMeans()` que l'on arrondi avec `round()`.
4.  On renomme les noms avec `names()` et on affiche le résultat dans un dataframe avec `as.data.frame()`.

```{r}

#1

df_rep_b <- data[,paste("Q9_", 1:13, sep = "")]

#2

df_rep_b <- replace(df_rep_b, is.na(df_rep_b), 0)

#3

moy_rep_b <- round(colMeans(df_rep_b), 2)

#4

names(moy_rep_b) <- c("Hypermarché, Supermarché","Hard discount","Epiceries indépendantes, de quartier, épiceries fines","Magasins de surgelés","Magasins spécialisés Bio","Marché","Directement aux agriculteurs","Paniers en ligne réalisés par un intermédiaire","Artisans et commerçants spécialisés","Epicerie participative, associative, supermarché coopératif","Magasin alimentaire spécialisé dans le vrac ou les produits locaux","Magasin d’aide alimentaire","Autre")

as.data.frame(moy_rep_b)

```

#### Avec usage de library

-   Pour chaque fonction utiliser, on utilise `%>%` de dplyr pour incrémenter chaque fonction de manière fluide.

1.  On sélectionne les colonnes qui nous intéressent avec `select()`.
2.  On modifie notre nouveau dataframe en remplaçant toute les valeur NA par 0 avec `mutate` et on calcule la moyenne par col avec `colMeans()`.
3.  On modifie les noms des lieux d'achat et on affiche le tableau avec `kable()`.

```{r}
#1

moy_rep_b <- data %>% select(Q9_1:Q9_13) %>% 
  
#2
  
  mutate(across(everything(), ~replace_na(., 0))) %>% 
  
  colMeans()

#3

names(moy_rep_b) <- c("Hypermarché, Supermarché","Hard discount","Epiceries indépendantes, de quartier, épiceries fines","Magasins de surgelés","Magasins spécialisés Bio","Marché","Directement aux agriculteurs","Paniers en ligne réalisés par un intermédiaire","Artisans et commerçants spécialisés","Epicerie participative, associative, supermarché coopératif","Magasin alimentaire spécialisé dans le vrac ou les produits locaux","Magasin d’aide alimentaire","Autre")

kable(round(moy_rep_b,2), caption = "Moyenne de la répartition du budget en fonction du lieu d'achat", col.names = c("Lieux d'achat","Moyenne de la répartition du budget (%)")) %>% 
  kable_styling(latex_options = "striped")
  
```

### 21.part du budget consacré aux modalités 6/7/8

#### Avec R natif

1. On sélectionne les lignes pour notre critère de sélection à laide de `paste()`.
2. À l'aide de la fonction `apply()` on regarde pour chaque valeur si elle est inférieure à 7 et non manquante (lieu fréquenté) et on retourne le booléen TRUE avec `all()` si la condition est respectée sur toute la ligne (tout les lieux) ou FALSE sinon.
3. On sélectionne les lignes et colonnes qui nous intéressent et on remplace les valeurs manquantes par 0 avec `replace()`.
4. On fait la moyenne par colonne avec `colMeans` et on retransforme en dataframe avec `as.data.frame`.
5. On modifie les noms avec `dimnames()`.

```{r}
#1

df_678 <- data[,paste("Q6_", 6:8, sep = "")]

#2

lignes_a_conserver <- apply(df_678, MARGIN = 1, function(x) all(x < 7 & !is.na(x)))

#3

df_678_b <- data[lignes_a_conserver,paste("Q9_", 6:8, sep = "")]
df_678_b <- replace(df_678_b, is.na(df_678_b), 0)

#4

moy_b_678 <- round(colMeans(df_678_b),2)
moy_b_678 <- as.data.frame(moy_b_678)

#5

dimnames(moy_b_678)[[1]] <- c("Marché","Directement aux agriculteurs","Paniers en ligne réalisés par un intermédiaire")
dimnames(moy_b_678)[[2]] <- "Moyenne du budget dédié pour ceux qui fréquentes ces lieux (%)"

moy_b_678

```
#### Avec usage de library
-   Pour chaque fonction utiliser, on utilise `%>%` de dplyr pour incrémenter chaque fonction de manière fluide.
1.  On sélectionne les lignes avec toutes les valeurs de la question Q9_6 à Q9_8 qui sont inférieur à 7 et non manquantes avec `filter()`.
2. On sélectionne les colonnes qui nous intéressent avec `select()` et on fait la moyenne par colonne avec `colMeans()`.
3. On fait la mise en forme du tableau avec `kablee()`.
```{r}
moy_b_678 <- data %>% filter(apply(across(Q6_6:Q6_8, ~ .x < 7 & !is.na(.x)),1,all) ) %>% 
  select(Q9_6:Q9_8) %>% 
  mutate(across(Q9_6:Q9_8, ~replace_na(., 0))) %>% 
  colMeans() 


names(moy_b_678) <- c("Marché","Directement aux agriculteurs","Paniers en ligne réalisés par un intermédiaire")

kable(round(moy_b_678,2), caption = "Moyenne du budget dédié par ceux qui fréquentent tous ces lieux d’achat.", col.names = c("Lieux d'achat","Moyenne de la répartition du budget (%)")) %>% 
  kable_styling(latex_options = "striped")
  
```
### 22. Le budget médian consacré aux modalités 6/7/8 par les acheteurs 

#### Avec R natif

(1) On sélectionne les colonnes pour notre critère de sélection à laide de `paste()`
(2) On remplace les valeurs manquantes par des 0 grâce à `replace()` et l'utilisation de `is.na()` pour les détecter
(3) À l'aide de la fonction `apply()` on applique la médiane sur l'ensemble des colonnes
(4) On modifie les noms des colonnes avec `names()`
(5) On transforme au format 'dataframe' le tableau et on le transpose afin d'obtenir les résultats dans le bon sens avec `t()`
(6) On garde uniquement les colonnes 6 à 8 car se sont les modalités de la question 9 du questionnaire qui nous intéressent avec l'opérateur de sélection `[]`
(7) On affiche le tableau de résultat avec `print()`


```{r}
# (1)

data_question_9 <- data[,paste("Q9_", 1:13, sep = "")]

# (2)

data_question_9 <- replace(data_question_9, is.na(data_question_9), 0)

# (3)

mediane_question_9 <- apply(data_question_9, 2, median, na.rm = TRUE)

# (4)

names(mediane_question_9) <- c("Hypermarché, Supermarché","Hard discount","Epiceries indépendantes, de quartier, épiceries fines","Magasins de surgelés","Magasins spécialisés Bio","Marché","Directement aux agriculteurs","Paniers en ligne réalisés par un intermédiaire","Artisans et commerçants spécialisés","Epicerie participative, associative, supermarché coopératif","Magasin alimentaire spécialisé dans le vrac ou les produits locaux","Magasin d’aide alimentaire","Autre")

# (5)

mediane_question_9 <- as.data.frame(t(mediane_question_9))  # Transpose pour avoir les valeurs en colonnes

# (6)

mediane_question_9 <- mediane_question_9[, 6:8]

# (7)

print(mediane_question_9)

```

#### Avec usage de library

(1) On sélectionne les colonnes correspondant aux questions Q9 à l’aide de `select(starts_with("Q9_"))` puis on remplace les valeurs manquantes par des zéros grâce à `mutate()` combiné à `across()` et `replace_na()`

(2) On calcule la médiane pour chaque colonne (chaque type de lieu) à l’aide de `summarise()` et `across()`, puis on renomme chaque colonne avec des libellés explicites correspondant aux types de lieux via `rename_with()`.

(3) On sélectionne uniquement les colonnes 6 à 8 car ce sont celles qui nous intéressent dans le cadre de l’analyse de la question 9 du questionnaire, à l’aide de la fonction `select()` 

(4) On affiche la table des résultat de façon élégante avec `kable()`


```{r}

# (1)  
data_question_9 <- data %>%
  select(starts_with("Q9_")) %>%
  mutate(across(everything(), ~replace_na(., 0)))

# (2) 

mediane_question_9 <- data_question_9 %>%
  summarise(across(everything(), ~median(.x, na.rm = TRUE))) %>%
  rename_with(~c(
    "Hypermarché, Supermarché",
    "Hard discount",
    "Epiceries indépendantes, de quartier, épiceries fines",
    "Magasins de surgelés",
    "Magasins spécialisés Bio",
    "Marché",
    "Directement aux agriculteurs",
    "Paniers en ligne réalisés par un intermédiaire",
    "Artisans et commerçants spécialisés",
    "Epicerie participative, associative, supermarché coopératif",
    "Magasin alimentaire spécialisé dans le vrac ou les produits locaux",
    "Magasin d’aide alimentaire",
    "Autre"
  ))

# (3)
mediane_question_9 <- mediane_question_9 %>%
  select(6:8)

# (4) 

kable(mediane_question_9) %>% 
  kable_styling(latex_options = "striped")

```

### 24.Produits achetés auprès d'un agriculteur ou non?
#### Avec R natif
1. On la colonne qui nous intéresse. 
2. On fait le tableau de proportion de la table de fréquence d'occurrences de réponse de la question 22 avec `table()` et `prop.table()`. On multiplie par 100 pour avoir un pourcentage.
3. On change le nom des valeurs avec `names()`.
4. On transforme en dataframe avec `as.data.frame()` et on change le nom de la colonne des valeurs avec `dimnames()`.
```{r}
#1

df_Q22 <- data[,"Q22"]

#2

tb_Q22 <- prop.table(table(df_Q22))*100

#4

names(tb_Q22) <- c("Oui, et j’en ai acheté au cours du mois de Septembre","Oui, mais je n’en ai pas acheté au cours du mois de Septembre","Non, j’en ai déjà acheté de cette façon mais ce n’est plus le cas","Non, je n’en ai jamais acheté de cette façon")

#4

df_Q22 <- as.data.frame(round(tb_Q22,2))
dimnames(df_Q22)[[2]] <- c("Achetez-vous des produits vendus directement par l’agriculteur ?","Répartition (%)")

df_Q22
```
#### Avec usage de library
-   Pour chaque fonction utiliser, on utilise `%>%` de dplyr pour incrémenter chaque fonction de manière fluide.
1. On sélectionne la colonne qui nous intéresse avec `select()`.
2. On fait le tableau de proportion de la table de fréquence d'occurrences de réponse de la question 22 avec `table()` et `prop.table()`. On multiplie par 100 pour avoir un pourcentage.
3. On change le nom des valeurs avec `names()`.
4. On met en forme avec `kable()`. 
```{r}
tb_Q22 <- data %>% select(Q22) %>% 
  table() %>% 
  prop.table()*100
names(tb_Q22) <- c("Oui, et j’en ai acheté au cours du mois de Septembre","Oui, mais je n’en ai pas acheté au cours du mois de Septembre","Non, j’en ai déjà acheté de cette façon mais ce n’est plus le cas","Non, je n’en ai jamais acheté de cette façon")

kable(round(tb_Q22, 2), col.names = c("Achetez-vous des produits vendus directement par l’agriculteur ?","Répartition (%)")) %>% 
  kable_styling(latex_options = "striped")

```

### 25. Quelles motivations à fréquenter le marché

#### Avec R natif

(1) On sélectionne les colonnes pour notre critère de sélection à laide de `subset()` et de l'agument `select()`
(2) On initialise les trois tableaux pour les 3 premières motivations
(3) On crée les 3 tableaux de pourcentages pour les motivations des clients
    (1) On crée une boucle `for()`
    (2) On convertit en numérique au cas où par précaution avec `as.numeric()` et on retire les potentiels messages d'avertissements générés par R avec s`uppressWarnings()`
    (3) On garde les lignes qui n'ont pas de valeurs manquantes au moyen de is.na() auquel on ajoute un `!` devant pour obtenir `!is.na()`. Le `!` est la négation en langage R
    (4) On crée la table des effectifs avec `table()`
    (5) On transforme cette table en table de pourcentages avec les opérateurs classiques de R (`/` pour la division et `sum()` pour la somme) qu'on arrondie à 2 chiffres après la virgule à l'aide de `round()`
    (6) On effectue un trie décroissant avec `sort()` et l'argument d`ecreasing = TRUE`
    (7) On affiche avec `cat()`, la modalité la plus fréquente avec `which.max()`. La fonction `paste0()` permet de concaténer
    (8) On affecte au bon tableau les opérations précédentes avec `if()` et `<-`
(4) On affiche le tableau de résultat avec `print()`

```{r,}
# (1)
data_question_21 <- subset(data, select = 58:60)

# (2) 
motivation_1 <- NULL
motivation_2 <- NULL
motivation_3 <- NULL

# (3)
for (i in 1:3) {
  
  Motivation <- data_question_21[[i]]
  
  Motivation <- suppressWarnings(as.numeric(Motivation))
  

  Motivation <- Motivation[!is.na(Motivation)]

  freq <- table(Motivation)
  

  pct <- round(100 * freq / sum(freq), 1)
  

  pct_sorted <- sort(pct, decreasing = TRUE)
  

  cat(paste0("Modalité la plus fréquente pour Motivation_", i, " : ", 
             names(which.max(pct)), " (", max(pct), "%)\n\n"))
  
  if (i == 1) motivation_1 <- pct_sorted
  if (i == 2) motivation_2 <- pct_sorted
  if (i == 3) motivation_3 <- pct_sorted
}

# (4)
print(motivation_1)
print(motivation_2)
print(motivation_3)

```

#### Avec usage de library

(1) On sélectionne les colonnes pour notre critère de sélection à l’aide de `select() `du package `dplyr()`, qui permet une syntaxe plus claire et concise que `subset()`
(3) On crée les 3 tableaux de pourcentages pour les motivations des clients
    (1) On crée une boucle `for()`
    (2) On convertit en numérique au cas où par précaution avec `as.numeric()` et on retire les potentiels messages d'avertissements générés par R avec s`uppressWarnings()`
    (3) On garde les lignes qui n'ont pas de valeurs manquantes au moyen de is.na() auquel on ajoute un `!` devant pour obtenir `!is.na()`. Le `!` est la négation en langage R
    (4) On crée la table des effectifs avec `table()`
    (5) On transforme cette table en table de pourcentages avec les opérateurs classiques de R (`/` pour la division et `sum()` pour la somme) qu'on arrondie à 2 chiffres après la virgule à l'aide de `round()`
    (6) On effectue un trie décroissant avec `sort()` et l'argument d`ecreasing = TRUE`
    (7) On affiche avec `cat()`, la modalité la plus fréquente avec `which.max()`. La fonction `paste0()` permet de concaténer
    (8) On affecte au bon tableau les opérations précédentes avec `if()` et `<-`
(4) On affiche le tableau de résultat avec cat() et de façon élégante avec `kable()`

```{r}

# (1) 
data_question_21 <- data %>%
  select(58:60)

# (2) 
motivation_1 <- NULL
motivation_2 <- NULL
motivation_3 <- NULL

# (3)
for (i in 1:3) {
  
  Motivation <- data_question_21[[i]]
  
  Motivation <- suppressWarnings(as.numeric(Motivation))
  
  Motivation <- Motivation[!is.na(Motivation)]
  
  freq <- table(Motivation)
  
  pct <- round(100 * freq / sum(freq), 1)
  
  pct_sorted <- sort(pct, decreasing = TRUE)

  cat(paste0("Modalité la plus fréquente pour Motivation_", i, " : ", 
             names(which.max(pct)), " (", max(pct), "%)\n\n"))
  
  if (i == 1) motivation_1 <- pct_sorted
  if (i == 2) motivation_2 <- pct_sorted
  if (i == 3) motivation_3 <- pct_sorted
}

# (4)
cat("Motivation 1\n")

kable(motivation_1) %>% 
  kable_styling(latex_options = "striped")

cat("Motivation 2\n")
kable(motivation_2) %>% 
  kable_styling(latex_options = "striped")

cat("Motivation 3\n")
kable(motivation_3) %>% 
  kable_styling(latex_options = "striped")

```

### 27.Quels produits achetés?
#### Avec R natif
1. On sélectionne la colonne qui nous intéresse pour répondre à la question.
2. On a un format qui n'est pas exploitable. On split chaque chaine de caractère pour avoir une liste des nombres à l'aide de la fonction `strsplit()` dans `lapply()`.
3. Le format n'est toujours pas exploitable, car on a des vecteurs dans des éléments de notre liste. Avec `unlist()`, on peut créer une seule liste. 
4. On supprime les éléments qui n'ont pas de valeur en cherchant leurs indices avec `which()`.
5. On transforme en facteur avec des niveaux allant de 1 à 19 avec `factor()` puis on les renomme.
6. On fait la table des fréquences des niveaux avec `table()` que l'on divise par le nombre de personnes qui achètent en comptant le nombre de valeur qui n'est pas NA avec `is.na()` et `sum()`. On multiplie par 100 et on arrondi avec `round()`.
7. On transforme en dataframe avec `as.data.frame()` et on renomme les colonnes avec `names()`.
```{r}
#1

dt_Q26 <- data$Q26

#2

dt_split <- lapply(dt_Q26,FUN = function(dt) strsplit(dt,"/")[[1]])

#3

dt_unlist <- unlist(dt_split)

#4

i <- which(dt_unlist=="")
dt_unlist <- dt_unlist[-i]

#5

dt_unlist <- factor(dt_unlist, levels = 1:19)
levels(dt_unlist) <- c("Fruits frais","Légumes frais","Miel","Produits de la Mer","Œufs","Volailles","Viande fraîche (Bœuf, Mouton, Porc, Agneau)","Charcuterie","Fromage","Yaourts","Autres produits laitiers","Pain","Farine","Pâtes","Olives, huile d’olive","Huiles (hors huile d’olive)","Boissons non alcoolisées","Produits d’épicerie salée (bocaux de légumes, plats cuisinés, etc...)","Produits d’épicerie sucrée (biscuits, confitures, compotes, etc...)")

#6

tb_freq <- round(table(dt_unlist)/sum(!is.na(dt_Q26))*100,2)

#7
tb_freq <- as.data.frame(tb_freq)
names(tb_freq) <- c("Produits","Fréquences d'achat (%)")

tb_freq

```
#### Avec usage de library
-   Pour chaque fonction utiliser, on utilise `%>%` de dplyr pour incrémenter chaque fonction de manière fluide.
1. On sélectionne la bonne colonne avec `select()`.
2. On transforme les valeurs en valeurs utilisables avec `strsplit()`, `apply()` (on a encore un dataframe)  et `unlist()`.
3. On enlève les éléments `""` qui ne sont pas des valeurs.
4. On transforme en facteur avec des niveaux allant de 1 à 19 avec les labels associé à chaque niveau avec `factor()`.
5. On fait la table des fréquences avec `table()` que l'on divise par le nombre de personnes qui ont acheté des produits en comptant le nombre de valeurs non manquante avec `is.na()` et `sum` et on multiplie par 100.
6. On fait la mise en forme du tableau arrondi avec `round()` et `kable()`.
```{r}
#1

dt_unlist <- data %>% 
  select(Q26) %>%

#2
  
  apply(FUN = function(dt) strsplit(dt,"/")[[1]], MARGIN = 1) %>% 
  unlist()

#3
  
i <- which(dt_unlist=="")
dt_unlist <- dt_unlist[-i]

#4

tb_freq <- dt_unlist %>% factor(levels = 1:19, labels = c("Fruits frais","Légumes frais","Miel","Produits de la Mer","Œufs","Volailles","Viande fraîche (Bœuf, Mouton, Porc, Agneau)","Charcuterie","Fromage","Yaourts","Autres produits laitiers","Pain","Farine","Pâtes","Olives, huile d’olive","Huiles (hors huile d’olive)","Boissons non alcoolisées","Produits d’épicerie salée (bocaux de légumes, plats cuisinés, etc...)","Produits d’épicerie sucrée (biscuits, confitures, compotes, etc...)")) %>% 
  
#5
  
  table()/sum(!is.na(data$Q26))*100

#6

kable(round(tb_freq,2), caption = "Fréquences des produits achetés", col.names = c("Produits", "Fréquences (%)")) %>%
  kable_styling(latex_options = "striped")
  
```
