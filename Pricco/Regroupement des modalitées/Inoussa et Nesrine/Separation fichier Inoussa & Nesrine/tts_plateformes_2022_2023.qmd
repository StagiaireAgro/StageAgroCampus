---
title: "tts_plateformes_2022_2023"
format: html
editor: visual
---

# I) Chargement des bibliothèques nécessaires

```{r,message=FALSE}

# Pour lire les fichiers CSV
library(vroom)

# Pour manipuler et détecter les chaînes de caractères
library(stringr)

# Pour gérer les accents et normaliser les chaînes
library(stringi)
library(fs)

# Le tidyverse est un méta-package qui regroupe plusieurs packages R
# utiles pour la manipulation, la transformation, et la visualisation de données :
# - ggplot2 : pour la visualisation
# - dplyr : pour la manipulation de données (filtrer, trier, grouper...)
# - tidyr : pour le reshaping (pivot_longer, pivot_wider, etc.)
# - readr : pour lire des fichiers plats (CSV, TSV...)
# - purrr : pour la programmation fonctionnelle (map, etc.)
# - tibble : pour manipuler des data frames modernes
# - stringr : pour manipuler des chaînes de caractères
# - forcats : pour manipuler des facteurs

```

# II) Importation des fichiers

```{r}
dossier_racine <- "data/2022-2023"
fichiers <- dir_ls(path = dossier_racine, recurse = TRUE, glob = "*.csv")
noms_fichiers <- path_ext_remove(path_file(fichiers))
datasets <- lapply(fichiers, function(file) vroom(file))
names(datasets) <- noms_fichiers
View(datasets)
```


# III) Harmonisation des noms de colonnes de toutes les plateformes


```{r}
# On ajoute la colonne pour le bio 

datasets$ruche_oui_2022$productIsOrganic <- NA
datasets$ruche_oui_2023$productIsOrganic <- NA
```


```{r}
lapply(datasets, function(x) names(x))
```


```{r}
# Vecteurs de sélection par préfixe
selections <- list(
  cagette <- c("orderProductPrice", "orderQuantity", "mois", "annee", "productName", "productIsOrganic", "productConditioningQuantity", "productConditioningUnit", "distributionZipCode")
,
  socleo <- c("value", "quantite_com", "mois", "annee", "name", "is_organic", "quantite_cond", "unite_conditionnement", "code_postal")
,
  ruche <- c("price_ttc_item", "nb_item", "mois", "annee", "product_name", "x", "weight_raw_item", "quantityunit", "hive_zipcode")
,
  coop <- c("price", "quantite_unite", "mois", "annee", "name", "is_organic", "quantite_cond", "conditionnement", "code_postal")

)

# Application avec lapply()
selected_datasets <- lapply(names(datasets), function(name) {
  df <- datasets[[name]]
  prefix <- sub("_.*", "", name)  # extrait le préfixe avant le premier "_"
  if (prefix %in% names(selections)) {
    return(df[, selections[[prefix]]])
  } else {
    return(NULL)  
  }
})

# On nomme les datasets pour garder l'association
names(selected_datasets) <- names(datasets)

```


```{r}

# On applique la fonction 
liste_datasets <- selection_colonnes(datasets)
```


```{r}

# Vérification du bon fonctionnement de la fonction
lapply(liste_datasets, function(x) names(x))
```


```{r}

cagette_Abricot_2022  <- datasets$cagette_Abricot_2022 |> 
  select(2:3,5:8,12,15:16)

socleo_2022  <- datasets$socleo_2023 |> 
  select(1,4:8,11:12,13)

ruche_oui_2022  <- datasets$ruche_oui_2022 |> 
  select(3:4,12,14:15,21:22,24,26)

coop_circuit_2022  <- datasets$coop_circuit_2022 |> 
  select(1:4,6:10)
```


```{r}

library(fs)

chemin_absolue <-  dir_ls(path = "data/2022-2023/", recurse = TRUE, glob = "*.csv")
noms_fichiers <- path_ext_remove(path_file(chemin_absolue))
datasets <- lapply(chemin_absolue, function(file) fread(file))
names(datasets) <- noms_fichiers

# Ajout de la colonne NA aux jeux 
datasets$ruche_oui_2022$productIsOrganic <- NA
datasets$ruche_oui_2023$productIsOrganic <- NA
View(datasets)

# Colonne de cagette à garder 
colonne_cagette_a_garder <- c(
  "orderProductPrice", "orderQuantity", "mois", "annee", "productName", 
  "productIsOrganic", "productConditioningQuantity", "productConditioningUnit", 
  "distributionZipCode")
indices_cagette <- startsWith(names(datasets), "cagette")

datasets[indices_cagette] <- lapply(datasets[indices_cagette], function(x) {
  select(x, any_of(colonne_cagette_a_garder))
})


# Colonne de ruche qui dit oui à garder 

colonne_ruche_a_garder <- c(
  "price_ttc_item","nb_item","mois","annee", "product_name","productIsOrganic",
  "weight_raw_item", "quantityunit", "hive_zipcode")

indices_ruche <- startsWith(names(datasets), "ruche")

datasets[indices_ruche] <- lapply(datasets[indices_ruche], function(x) {
  select(x, any_of(colonne_ruche_a_garder))
})

# Colonne de socleo qui dit oui à garder 

colonne_socleo_a_garder <- c(
  "value", "quantite_com","mois","annee","name","is_organic","quantite_cond",
  "unite_conditionnement", "code_postal")

indices_socleo <- startsWith(names(datasets), "socleo")

datasets[indices_socleo] <- lapply(datasets[indices_socleo], function(x) {
  select(x, any_of(colonne_socleo_a_garder))
})

# Colonne de coop circuit qui dit oui à garder 

colonne_coop_circuit_a_garder <- c(
  "price", "quantite_unite","mois", "annee", "name", "is_organic", "quantite_cond",
  "conditionnement","code_postal") 

indices_coop_circuit <- startsWith(names(datasets), "coop_circuit")

datasets[indices_coop_circuit] <- lapply(datasets[indices_coop_circuit], function(x) {
  select(x, any_of(colonne_coop_circuit_a_garder))
})

# Renommer toutes les noms de colonnes des bases aux noms de celui de cagette

datasets[!indices_cagette] <- lapply(datasets[!indices_cagette], function(df) {
  df <- select(df, everything())
  colnames(df) <- colonne_cagette_a_garder
  return(df)
})

liste_datasets_final <- lapply(names(datasets), function(nom) {
  df <- datasets[[nom]]
  df$plateforme <- str_split(nom, "_")[[1]][1]
  df
})

names(liste_datasets_final) <- names(datasets)

View(liste_datasets_final)

```
