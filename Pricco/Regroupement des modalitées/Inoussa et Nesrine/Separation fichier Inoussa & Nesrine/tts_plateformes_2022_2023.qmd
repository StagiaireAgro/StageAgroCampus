---
title: "tts_plateformes_2022_2023"
format: html
editor: visual
---

# I) Chargement des bibliothèques nécessaires

```{r,message=FALSE}

# Pour lire les fichiers CSV
library(vroom)

# Pour manipuler et détecter les chaînes de caractères
library(stringr)

# Pour gérer les accents et normaliser les chaînes
library(stringi)
library(fs)

# Le tidyverse est un méta-package qui regroupe plusieurs packages R
# utiles pour la manipulation, la transformation, et la visualisation de données :
# - ggplot2 : pour la visualisation
# - dplyr : pour la manipulation de données (filtrer, trier, grouper...)
# - tidyr : pour le reshaping (pivot_longer, pivot_wider, etc.)
# - readr : pour lire des fichiers plats (CSV, TSV...)
# - purrr : pour la programmation fonctionnelle (map, etc.)
# - tibble : pour manipuler des data frames modernes
# - stringr : pour manipuler des chaînes de caractères
# - forcats : pour manipuler des facteurs

```

# II) Importation des fichiers

```{r}
dossier_racine <- "data/2022-2023"
fichiers <- dir_ls(path = dossier_racine, recurse = TRUE, glob = "*.csv")
noms_fichiers <- path_ext_remove(path_file(fichiers))
datasets <- lapply(fichiers, function(file) vroom(file))
names(datasets) <- noms_fichiers
View(datasets)
```


# III) Harmonisation des noms de colonnes de toutes les plateformes


```{r}
# On ajoute la colonne pour le bio 

datasets$ruche_oui_2022$productIsOrganic <- NA
datasets$ruche_oui_2023$productIsOrganic <- NA
```


```{r}
# Colonne de cagette à garder 
colonne_cagette_a_garder <- c(
  "orderProductPrice", "orderQuantity", "mois", "annee", "productName", 
  "productIsOrganic", "productConditioningQuantity", "productConditioningUnit", 
  "distributionZipCode")
indices_cagette <- startsWith(names(datasets), "cagette")

datasets[indices_cagette] <- lapply(datasets[indices_cagette], function(x) {
  select(x, any_of(colonne_cagette_a_garder))
})


# Colonne de ruche qui dit oui à garder 
colonne_ruche_a_garder <- c(
  "price_ttc_item","nb_item","mois","annee", "product_name","productIsOrganic",
  "weight_raw_item", "quantityunit", "hive_zipcode")

indices_ruche <- startsWith(names(datasets), "ruche")

datasets[indices_ruche] <- lapply(datasets[indices_ruche], function(x) {
  select(x, any_of(colonne_ruche_a_garder))
})

# Colonne de socleo qui dit oui à garder 
colonne_socleo_a_garder <- c(
  "value", "quantite_com","mois","annee","name","is_organic","quantite_cond",
  "unite_conditionnement", "code_postal")

indices_socleo <- startsWith(names(datasets), "socleo")

datasets[indices_socleo] <- lapply(datasets[indices_socleo], function(x) {
  select(x, any_of(colonne_socleo_a_garder))
})

# Colonne de coop circuit qui dit oui à garder 
colonne_coop_circuit_a_garder <- c(
  "price", "quantite_unite","mois", "annee", "name", "is_organic", "quantite_cond",
  "conditionnement","code_postal") 

indices_coop_circuit <- startsWith(names(datasets), "coop_circuit")

datasets[indices_coop_circuit] <- lapply(datasets[indices_coop_circuit], function(x) {
  select(x, any_of(colonne_coop_circuit_a_garder))
})

# Renommer toutes les noms de colonnes des bases aux noms de celui de cagette
datasets[!indices_cagette] <- lapply(datasets[!indices_cagette], function(df) {
  df <- select(df, everything())
  colnames(df) <- colonne_cagette_a_garder
  return(df)
})

liste_datasets_final <- lapply(names(datasets), function(nom) {
  df <- datasets[[nom]]
  df$plateforme <- str_split(nom, "_")[[1]][1]
  df
})

names(liste_datasets_final) <- names(datasets)

View(liste_datasets_final)

```

# IV) Fusion de tous les jeux de données sauf cagette

```{r}
liste_datasets_final_sans_cagette <- liste_datasets_final[!indices_cagette]

combinaison <- do.call(rbind, liste_datasets_final_sans_cagette)
View(combinaison)
```

