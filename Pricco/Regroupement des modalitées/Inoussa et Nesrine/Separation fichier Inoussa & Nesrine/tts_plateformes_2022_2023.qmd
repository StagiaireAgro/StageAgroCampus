---
title: "tts_plateformes_2022_2023"
format: html
editor: visual
---

# I) Chargement des bibliothèques nécessaires

```{r,message=FALSE}

# Pour lire les fichiers CSV
library(vroom)

# Pour manipuler et détecter les chaînes de caractères
library(stringr)

# Pour gérer les accents et normaliser les chaînes
library(stringi)
library(fs)

# Le tidyverse est un méta-package qui regroupe plusieurs packages R
# utiles pour la manipulation, la transformation, et la visualisation de données :
# - ggplot2 : pour la visualisation
# - dplyr : pour la manipulation de données (filtrer, trier, grouper...)
# - tidyr : pour le reshaping (pivot_longer, pivot_wider, etc.)
# - readr : pour lire des fichiers plats (CSV, TSV...)
# - purrr : pour la programmation fonctionnelle (map, etc.)
# - tibble : pour manipuler des data frames modernes
# - stringr : pour manipuler des chaînes de caractères
# - forcats : pour manipuler des facteurs

library(tidyverse)

library(purrr)

# Export des fichiers au format Excel 
library(writexl)

library(tibble)

```

# II) Documentation des variables d'intérêts pour le calcul du prix au kilogramme

| Variable | Définition | Unité |
|----|----|----|
| orderProductPrice | Unités de mesure | Euro |
| orderQuantity | Nombre d'une unité de produit acheté | Sans unité |
| mois | Mois | Mois |
| annee | Année | Année |
| productName | Noms du produit | Sans unité |
| productIsOrganic | Produit est bio | Sans unité |
| productConditioningQuantity | Poids d'une unité de produit | Gramme, kilogramme, pièce |
| productConditioningUnit | Unités de mesure | gramme, kilogramme, pièce |
| distributionZipCode | Code postal | Sans unité |
| plateforme | Plateformes partenaires du projet Pricco | Sans unité |

# III) Importation des fichiers

```{r,message=FALSE}
dossier_racine <- "data/2022-2023"
fichiers <- dir_ls(path = dossier_racine, recurse = TRUE, glob = "*.csv")
noms_fichiers <- path_ext_remove(path_file(fichiers))
datasets <- lapply(fichiers, function(file) vroom(file))
names(datasets) <- noms_fichiers
View(datasets)
```

# IV) Harmonisation des noms de colonnes de toutes les plateformes

```{r}
# On ajoute la colonne pour le bio 

datasets$ruche_oui_2022$productIsOrganic <- NA
datasets$ruche_oui_2023$productIsOrganic <- NA
```

```{r}
# Colonne de cagette à garder 
colonne_cagette_a_garder <- c(
  "orderProductPrice", "orderQuantity", "mois", "annee", "productName", 
  "productIsOrganic", "productConditioningQuantity", "productConditioningUnit", 
  "distributionZipCode")
indices_cagette <- startsWith(names(datasets), "cagette")

datasets[indices_cagette] <- lapply(datasets[indices_cagette], function(x) {
  select(x, any_of(colonne_cagette_a_garder))
})


# Colonne de ruche qui dit oui à garder 
colonne_ruche_a_garder <- c(
  "price_ttc_item","nb_item","mois","annee", "product_name","productIsOrganic",
  "weight_raw_item", "quantityunit", "hive_zipcode")

indices_ruche <- startsWith(names(datasets), "ruche")

datasets[indices_ruche] <- lapply(datasets[indices_ruche], function(x) {
  select(x, any_of(colonne_ruche_a_garder))
})

# Colonne de socleo qui dit oui à garder 
colonne_socleo_a_garder <- c(
  "value", "quantite_com","mois","annee","name","is_organic","quantite_cond",
  "unite_conditionnement", "code_postal")

indices_socleo <- startsWith(names(datasets), "socleo")

datasets[indices_socleo] <- lapply(datasets[indices_socleo], function(x) {
  select(x, any_of(colonne_socleo_a_garder))
})

# Colonne de coop circuit qui dit oui à garder 
colonne_coop_circuit_a_garder <- c(
  "price", "quantite_unite","mois", "annee", "name", "is_organic", "quantite_cond",
  "conditionnement","code_postal") 

indices_coop_circuit <- startsWith(names(datasets), "coop_circuit")

datasets[indices_coop_circuit] <- lapply(datasets[indices_coop_circuit], function(x) {
  select(x, any_of(colonne_coop_circuit_a_garder))
})

# Renommer toutes les noms de colonnes des bases aux noms de celui de cagette
datasets[!indices_cagette] <- lapply(datasets[!indices_cagette], function(df) {
  df <- select(df, everything())
  colnames(df) <- colonne_cagette_a_garder
  return(df)
})

liste_datasets_final <- lapply(names(datasets), function(nom) {
  df <- datasets[[nom]]
  df$plateforme <- str_split(nom, "_")[[1]][1]
  df
})

names(liste_datasets_final) <- names(datasets)

```

# V) Fusion de tous les jeux de données sauf cagette

```{r,warning=FALSE}
liste_datasets_final_sans_cagette <- liste_datasets_final[!indices_cagette]

combinaison <- do.call(rbind, liste_datasets_final_sans_cagette)
```

# VI) Séparation des fichiers par produit

## a) Définition de la liste de produits

```{r}
# Liste des produits alimentaires à rechercher
liste_produits <- c(
  "Clémentine", "Tomate", "Carotte", "Cerise", "Chou fleur",
  "Fraise", "Kiwi", "Lait", "Oeuf", "Poireau", "Poire", "Raisin",
  "Haricot vert", "Noix", "Pomme", "Boeuf", "Porc", "Poulet",
  "Laitue", "Lentille", "Abricot", "Pomme de terre", "Oignon",
  "Courgette", "Aubergine", "Asperge", "Banane", "Poivron",
  "Jus de pomme", "Celeri branche", "Concombre", "Prune",
  "Peche", "Potiron", "Melon", "Endive", "Nectarine")

# Mise en minuscules pour correspondance plus facile
liste_produits <- str_to_lower(liste_produits)

# On supprime les tirets pour correspondance plus facile
liste_produits <- gsub("-", " ", liste_produits, ignore.case = TRUE)

# On supprime les accents pour correspondance plus facile
liste_produits <- stri_trans_general(liste_produits, "Latin-ASCII")

# On ordonne la liste des noms de produits de manière decroissante selon
# le nombre de caractere de chaque mots
ordre <- order(nchar(gsub(" ", "", liste_produits)), decreasing = TRUE)
liste_produits <- liste_produits[ordre]
```

## b) Liste contenant toutes les déclinaisons possibles pour chaque nom de produit

```{r}
# Nettoyer une chaine de caractères (-> ici liste de noms de produits)
nettoyer <- function(x) {
  x <- stri_trans_general(str_to_lower(x), "Latin-ASCII") 
  x <- str_replace_all(x, "[^a-z ]", "")
  x <- trimws(x)
  return(x)
}

# Générer des expressions régulières à partir d'un mots ou liste de mots
creer_regex <- function(mots, suffixe = "(e?s)?", collapse = ".*") {
  sapply(mots, function(terme) {
    tokens <- str_split(terme, " ")[[1]] 
    regex_tokens <- paste0(tokens, suffixe)
    paste0(regex_tokens, collapse = collapse)
  })
}

# Creer un fichier excel standar permettant de rajoutter d'autres d'éclinaisons
creer_fichier_excel <- function(liste_de_produits, fichier = "autres_declinaisons.xlsx") {
  classeur <- createWorkbook() # Creer un classeur
  addWorksheet(classeur, "Ajoutez autres déclinaisons") # Ajouter une feuille nommée
  # Dataframe qui sera écrit dans la feuille excel
  data <- data.frame(
    "Nom de produit" = liste_de_produits,
    "Autres déclinaisons" = "",
    check.names = FALSE
  )
  # Ecriture du dataframe dans la feuille excel
  writeData(
    classeur, 
    sheet = "Ajoutez autres déclinaisons", 
    x = data, 
    startRow = 1,  # Début d'écriture à la première ligne
    colNames = TRUE # Considérer la première ligne comme le nom des colonnes
  )
  
  # Nombre de ligne et colonne du dataframe
  n_rows <- nrow(data) + 1 # Considérer la ligne des colonnes de données de la feuille excel
  n_cols <- ncol(data)
  
  # Ajouter de l'espace dans le nom des colonnes(Rendre plus lisible) 
  largeurs <- nchar(colnames(data)) + 5  # +5 pour un peu d’espace
  setColWidths(classeur, sheet = "Ajoutez autres déclinaisons", cols = 1:n_cols, widths = largeurs)
  
  # Mettre en gras et augmenter la taille des noms de colonnes de la feuille 
  header_style <- createStyle(textDecoration = "bold", fontSize = 12)
  addStyle(
    wb = classeur,
    sheet = "Ajoutez autres déclinaisons",
    style = header_style,
    rows = 1,
    cols = 1:n_cols,
    gridExpand = TRUE,
    stack = TRUE
  )
  # Par défaut les cellules excels sont vérouillées (Déverouiller pour tous les autres lignes)
  unlocked_style <- createStyle(locked = FALSE)
  addStyle(
    wb = classeur,
    sheet = "Ajoutez autres déclinaisons",
    style = unlocked_style,
    rows = 2:n_rows,
    cols = 1:n_cols,
    gridExpand = TRUE,
    stack = TRUE
  )
  # Appliquer donc la protection que sur les noms de colonnes de la feuille 
  protectWorksheet(
    wb = classeur,
    sheet = "Ajoutez autres déclinaisons",
    protect = TRUE,
    # Autoriser la sélection sur toutes les cellules (locked ou unlocked)
    lockSelectingLockedCells = FALSE,
    lockSelectingUnlockedCells = FALSE
  )
  
  saveWorkbook(classeur, fichier, overwrite = TRUE)
}

# Extraires des noms de produits toutes les declinaisons des noms de la liste de produit
trouver_declinaisons_nom_produit <- 
  function(dataset, col_produit, ls_produit, regex, fichier = NULL) {
  # Extraction des noms uniques de produits
  noms_des_produits <- nettoyer(dataset[[col_produit]])
  noms_des_produits_uniques <- unique(noms_des_produits)
  # Extraction des déclinaisons par produit
  liste_declinaisons <- sapply(seq_along(regex), function(i) {
    extractions <- str_extract(noms_des_produits_uniques, regex[i])
    extractions <- extractions[!is.na(extractions) & extractions != ""]
    unique(extractions)
  }, simplify = FALSE)

  names(liste_declinaisons) <- ls_produit
  
  # Ajouter d'autres déclinaisons extérieurs 
  if(!is.null(fichier)==TRUE){
    fichier <- na.omit(fichier)
    fichier[["Nom de produit"]] <- nettoyer(fichier[["Nom de produit"]])
    sapply(fichier[["Nom de produit"]], function(prod){
      res <- pull(fichier[fichier[["Nom de produit"]]==prod,"Autres déclinaisons"])
      declinaisons_suppl <- unlist(str_split(res, ";"))
      liste_declinaisons[[prod]] <<- unique(c(liste_declinaisons[[prod]], declinaisons_suppl))
    })
  }
  return(liste_declinaisons)
}
```

```{r}
# Creer les expressions reguliere de la liste des noms de produits
regex <- creer_regex(liste_produits) 

# Creaction du fichier excel en question permettant de rajouter dautres déclinaisons
# creer_fichier_excel(liste_produits)

# Declinaison obtenues de manière automatique
exemple <- read_excel("autres_declinaisons.xlsx")

# Declinaison obtenues de manière automatique
final_declinaisons <- trouver_declinaisons_nom_produit(
    dataset = combinaison,
    col_produit = "productName",
    ls_produit = liste_produits,
    regex = regex,
    fichier = exemple
  )

```

## c) Développement de la fonction split

```{r}
#  Fonction split par nom de produit
separation_fichiers <- function(data, liste_produits, liste_declinai_noms_produits) {

  #### Étape 0 : Ajout et nettoyage de la colonne `name_clean` dans `data`
  data <- data %>%
    mutate(
      name_clean = productName %>%
        str_to_lower() %>%
        stri_trans_general("Latin-ASCII") %>%
        gsub("-", " ", ., ignore.case = TRUE)
    )

  #### Étape 1 : On extrait les levels des produits
  levels_produits <- levels(as.factor(data$name_clean))

  #### Étape 2 : Création de la matrice de présence
  matrice_presence <- sapply(liste_declinai_noms_produits, function(declinaisons) {
    sapply(levels_produits, function(level) {
      any(str_detect(level, fixed(declinaisons))) * 1
    })
  })

  # Transposition pour avoir les produits en colonnes
  matrice_presence <- t(matrice_presence)

  # Calcul du nombre de correspondances pour chaque level
  nb_variantes_noms <- colSums(matrice_presence)

  # Ajouter cette ligne en bas de la matrice
  matrice_presence <- rbind(matrice_presence, nb_variantes_noms)

  #### Étape 3 : Identifier les noms qui correspondent à un seul produit
  levels_uniques <- names(nb_variantes_noms[nb_variantes_noms == 1])

  # On garde uniquement les colonnes de la matrice où une seule correspondance existe
  matrice_uniques <- matrice_presence[-nrow(matrice_presence), levels_uniques, drop = FALSE]

  #### Étape 4 : Créer un vecteur nom_produit proprement
  vecteur_nom_produit <- sapply(levels_uniques, function(level) {
    idx <- which(matrice_uniques[, level] == 1)
    if (length(idx) == 1) {
      return(liste_produits[idx])
    } else {
      return(NA)
    }
  }, USE.NAMES = TRUE)

  vecteur_nom_produit <- vecteur_nom_produit[!is.na(vecteur_nom_produit)]

  # Créer le dataframe de correspondance
  df_correspondance <- data.frame(
    name_clean = names(vecteur_nom_produit),
    nom_produit = unname(vecteur_nom_produit),
    stringsAsFactors = FALSE
  )

  #### Étape 5 : Générer data_ok en ajoutant nom_produit
  data_ok <- data %>%
    filter(name_clean %in% df_correspondance$name_clean) %>%
    left_join(df_correspondance, by = "name_clean")

  #### Étape 6 : Extraire les noms avec 0 ou plusieurs correspondances
  levels_pas_ok <- names(nb_variantes_noms[nb_variantes_noms != 1])

  matrice_pas_ok <- matrice_presence[-nrow(matrice_presence), levels_pas_ok, drop = FALSE]

  vecteur_nom_pas_ok <- sapply(levels_pas_ok, function(level) {
    idx <- which(matrice_pas_ok[, level] == 1)
    if (length(idx) == 0) {
      return(NA)
    } else {
      return(paste(liste_produits[idx], collapse = ";"))
    }
  }, USE.NAMES = TRUE)

  df_correspondance_pas_ok <- data.frame(
    name_clean = names(vecteur_nom_pas_ok),
    nom_produit = unname(vecteur_nom_pas_ok),
    stringsAsFactors = FALSE
  )

  #### Étape 7 : Générer data_pas_ok
  data_pas_ok <- data %>%
    filter(name_clean %in% df_correspondance_pas_ok$name_clean) %>%
    left_join(df_correspondance_pas_ok, by = "name_clean")

  #### Étape 8 : Identifier les lignes avec plusieurs noms dans data_pas_ok
  data_ambigus <- data_pas_ok %>%
    filter(str_detect(nom_produit, ";"))

  #### Étape 9 : Nettoyage des noms emboîtés
  data_ambigus_clean <- data_ambigus %>%
    rowwise() %>%
    mutate(
      noms_list = list(str_split(nom_produit, ";")[[1]] %>% str_trim())
    ) %>%
    mutate(
      noms_clean = list({
        noms <- noms_list
        noms[!sapply(noms, function(x) any(noms != x & str_detect(noms, fixed(x))))]
      })
    ) %>%
    mutate(
      nom_produit_new = ifelse(length(noms_clean) == 1, noms_clean[[1]], paste(noms_clean, collapse = ";"))
    ) %>%
    ungroup()

  #### Étape 10 : Extraire les lignes devenues "uniques" après nettoyage
  data_deplaces <- data_ambigus_clean %>%
    filter(!str_detect(nom_produit_new, ";")) %>%
    select(-nom_produit, -noms_list, -noms_clean) %>%
    rename(nom_produit = nom_produit_new)

  #### Étape 11 : Mettre à jour data_ok
  data_ok <- bind_rows(data_ok, data_deplaces)

  #### Étape 12 : Mettre à jour data_pas_ok sans les lignes déplacées
  data_pas_ok <- data_pas_ok %>%
    filter(!(name_clean %in% data_deplaces$name_clean))

  return(list(data_ok = data_ok, data_pas_ok = data_pas_ok))
}
```

## d) Application de la fonction split

```{r,message=FALSE,warning=FALSE}

# Test de la fonction : Fichier coop circuit 2021
system.time({ 
  resultats_2 <- separation_fichiers(
  data = combinaison,
  liste_produits = liste_produits,
  liste_declinai_noms_produits = final_declinaisons
)})


# On regarde séparemment le data_ok et data_pas_ok
data_prod_tries <- resultats_2$data_ok
data_prod_pas_tries <- resultats_2$data_pas_ok

```

# VII) Fusion de tous les fichiers de cagette

```{r,warning=FALSE}

# On extrait les tables cagette dans une liste
liste_datasets_cagette <- liste_datasets_final[indices_cagette]
```

```{r,warning=FALSE}
################## On fusionne les tables pommes ensemble

# Étape 1 : renommer les éléments pour grouper
noms_groupes <- sub("part_\\d+_", "", names(liste_datasets_cagette))

# Étape 2 : fusionner les data.frames par groupe
liste_datasets_cagette <- lapply(
  split(liste_datasets_cagette, noms_groupes),
  function(groupe) do.call(rbind, groupe)
)

liste_datasets_cagette[["cagette_Pomme_2022"]] <- unique(liste_datasets_cagette[["cagette_Pomme_2022"]])

liste_datasets_cagette[["cagette_Pomme_2023"]] <- unique(liste_datasets_cagette[["cagette_Pomme_2023"]])


```

```{r}
#################### On ajoute la nouvelle colonne nom_produit à toutes les tables cagette
# Liste des produits
liste_produits_alimentaires <- c(
  "Abricot", "Asperge", "Aubergine","Banane","Carotte","Cerise","Chou fleur",
  "Clémentine", "Concombre","Courgette","Céleri branche","Endive","Fraise",
  "Haricot vert","Kiwi","Laitue","Melon","Nectarine","Oignon","Poire",
  "Poireau","Poivron",
  "Pomme de terre","Pomme","Potiron","Prune","Pêche","Raisin","Tomate")

# Nettoyer les noms : minuscules + suppression des accents + remplacement des espaces par _
nettoyer_nom <- function(x) {
  x %>%
    tolower() %>%
    stri_trans_general("Latin-ASCII") %>%
    gsub("[^a-z0-9]+", " ", .) %>%
    gsub("_+$", "", .) %>%
    gsub("^_+", "", .)
}

# Noms nettoyés des produits
produits_nettoyes <- sapply(liste_produits_alimentaires, nettoyer_nom, USE.NAMES = FALSE)

# Création d'une table de correspondance entre produits nettoyés et noms originaux
produits_df <- data.frame(
  produit_clean = produits_nettoyes,
  produit_label = tolower(liste_produits_alimentaires),
  stringsAsFactors = FALSE
)

# Ajouter la colonne nom_produit dans chaque data frame
liste_datasets_cagette_nettoyee <- lapply(names(liste_datasets_cagette), function(nom_df) {
  df <- liste_datasets_cagette[[nom_df]]
  
  # Extraire le nom du produit dans le nom de la table
  produit_nom_match <- sub("cagette_(.*)_20[0-9]{2}", "\\1", nom_df)
  
  # Nettoyage de ce nom pour le faire correspondre
  produit_nom_clean <- nettoyer_nom(produit_nom_match)
  
  # Recherche du nom d'origine
  produit_label <- produits_df$produit_label[match(produit_nom_clean, produits_df$produit_clean)]
  
  # Ajoute directement le nom nettoyé (sans accents)
  df$nom_produit <- produits_df$produit_clean[match(produit_nom_clean, produits_df$produit_clean)]

  
  return(df)
})

# Réattribution des noms à la liste
names(liste_datasets_cagette_nettoyee) <- names(liste_datasets_cagette)

```

```{r}
# On fusionne toutes les tables de cagette en une seule
liste_finale_datasets_cagette <- do.call(rbind, liste_datasets_cagette_nettoyee)
```


# VIII) On vérifie la pertinence des données déjà classées par les fournisseurs 

```{r}

# On regarde toutes les déclinaisons de noms de produit possibles pour les fichiers cagette
vect_decli_cagette <- trouver_declinaisons_nom_produit(
    dataset = liste_finale_datasets_cagette,
    col_produit = "productName",
    ls_produit = liste_produits,
    regex = regex
  )
```


```{r}
# On attribue le bon nom de produit de la liste des 37 à chaque ligne 

# On retire la colonne contenant le type de produit 
liste_finale_datasets_cagette <- liste_finale_datasets_cagette |> select(-c(11))

# Test de la fonction : Fichier coop circuit 2021
system.time({ 
  liste_cagette_trie_et_pas_trie <- separation_fichiers(
  data = liste_finale_datasets_cagette,
  liste_produits = liste_produits,
  liste_declinai_noms_produits = vect_decli_cagette
)})


# On regarde séparemment le data_ok et data_pas_ok
cagette_prod_tries <- liste_cagette_trie_et_pas_trie$data_ok
cagette_prod_pas_tries <- liste_cagette_trie_et_pas_trie$data_pas_ok

```


# IX) Fusion de tous les fichiers de produits triés issus de toutes les plateformes

```{r}
# On supprime la colonne name_clean de data_prod_tries
data_prod_tries <- data_prod_tries |> select(-c("name_clean"))

# On supprime la colonne name_clean de cagette_prod_tries
cagette_prod_tries <- cagette_prod_tries |> select(-c("name_clean"))

# On fusionne toutes les tables de cagette en une seule
datasets_tts_plateformes_prod_tries <- rbind(cagette_prod_tries,data_prod_tries)

```


# X) Fusion des fichiers de produits pas triés en un seul 

```{r}

# On fusionne toutes les tables de cagette en une seule
data_prod_pas_tries_tts_platatefor <- rbind(cagette_prod_pas_tries,data_prod_pas_tries)

```

# XI) Indicateur de pureté pour les produits triés

```{r}

# Extraire les levels (uniques)
levels_productName <- unique(datasets_tts_plateformes_prod_tries$productName)
levels_nom_produit <- unique(datasets_tts_plateformes_prod_tries$nom_produit)

# Indicateur de pureté pour les produits triés
compter_occurrences_exclusives <- function(df, col_productName = "productName", col_nom_produit = "nom_produit") {
  # Étape 1 : trier les noms_produit du plus long au plus court (pour priorité aux plus spécifiques)
  levels_nom_produit <- unique(df[[col_nom_produit]])
  levels_nom_produit <- levels_nom_produit[order(nchar(levels_nom_produit), decreasing = TRUE)]
  
  # Étape 2 : récupérer tous les productName uniques
  all_product_names <- unique(df[[col_productName]])
  
  # Étape 3 : initialiser les noms déjà utilisés
  noms_assignés <- rep(FALSE, length(all_product_names))
  names(noms_assignés) <- all_product_names
  
  # Étape 4 : construire les tableaux
  resultats <- map(levels_nom_produit, function(nom_produit) {
    # Construire la regex pluriel + imbriqué
    mots <- str_split(nom_produit, " ")[[1]]
    mots_regex <- paste0("(", mots, ")(s|x)?")
    motif <- paste(mots_regex, collapse = "[- ]?")
    
    # Filtrer uniquement les noms encore disponibles
    names_disponibles <- all_product_names[!noms_assignés]
    
    # Compter les occurrences
    nb_occ <- str_count(tolower(names_disponibles), regex(motif, ignore_case = TRUE))
    
    # Conserver ceux avec une correspondance
    matched_names <- names_disponibles[nb_occ > 0]
    matched_counts <- nb_occ[nb_occ > 0]
    
    # Marquer ces noms comme assignés
    noms_assignés[matched_names] <<- TRUE
    
    # Retourner le tibble
    tibble(
      !!paste0("levels_", str_replace_all(nom_produit, " ", "_")) := matched_names,
      !!paste0("nb_occurrence_", str_replace_all(nom_produit, " ", "_")) := matched_counts
    )
  }) |> set_names(levels_nom_produit)
  
  return(resultats)
}


# On teste la fonction 
liste_table_indi_purete_prod_trie <- compter_occurrences_from_levels(levels_productName, levels_nom_produit)


```


# XII) On sépare en 37 tables

## a) Développement de la fonction pour split en 37 tables

```{r}

split_data_ok_par_produit <- function(data_ok) {
  # Vérification de la présence de la colonne nom_produit
  if (!"nom_produit" %in% colnames(data_ok)) {
    stop("La colonne 'nom_produit' est absente de data_ok")
  }

  # Découpage automatique en liste de data frames, un par produit
  liste_data_par_produit <- split(data_ok, data_ok$nom_produit)

  return(liste_data_par_produit)
}

```

## b) Application de la fonction

```{r}
# Test de la fonction : data_ok de coop circuit 2021
liste_tables_37_produit_bruts <- split_data_ok_par_produit(datasets_tts_plateformes_prod_tries)

# Accéder au sous-dataframe pour le produit "pomme"
data_tomate <- liste_tables_37_produit_bruts[["tomate"]]

# Voir tous les noms de produits
names(data_tomate)

```


# XIII) Tableau de comptage du nombre de levels par produit après le split pour les produits bruts

```{r}

table_levels_par_prod_apres_split_prod_bruts <- datasets_tts_plateformes %>%
  group_by(nom_produit) %>%
  summarise(`nb_levels_prod_bruts` = n_distinct(productName)) %>%
  arrange(desc(`nb_levels_prod_bruts`)) %>%
  rename(`nom_prod` = nom_produit)

View(table_levels_par_prod_apres_split_prod_bruts)
```

# XIV) Tableau de comptage du nombre de levels par produit après le split pour les produits transformés

```{r}
# On sélectionne les lignes non vides de data_prod_pas_tries
data_produits_multiples <- data_prod_pas_tries |> filter(!is.na(nom_produit))
```

```{r}
library(stringr)
library(dplyr)
library(tibble)
library(purrr)
library(stringi)
library(tidyr)


# 2. Liste des produits
liste_produit <- c("celeri branche", "pomme de terre", "haricot vert", "clementine",
                   "jus de pomme", "chou fleur", "courgette", "aubergine", "concombre",
                   "nectarine", "lentille", "carotte", "poireau", "abricot", "asperge",
                   "poivron", "potiron", "tomate", "cerise", "fraise", "raisin", "poulet",
                   "laitue", "oignon", "banane", "endive", "poire", "pomme", "boeuf",
                   "prune", "peche", "melon", "kiwi", "lait", "oeuf", "noix", "porc")

# 3. Fonction de normalisation

normalize_text <- function(x) {
  x %>%
    str_to_lower() %>%
    stri_trans_general("Latin-ASCII") %>%
    gsub("-", " ", ., fixed = TRUE) %>%
    gsub("(s|x)\\b", "", ., perl = TRUE) %>%  # pluriels
    gsub("\\bde\\b|\\bet\\b|\\baux\\b|\\bdes\\b|\\ble\\b|\\bla\\b", "", ., perl = TRUE) %>%
    str_squish()
}



# 4. Normalisation produits et tri par longueur décroissante
liste_produit_sorted <- liste_produit[order(-nchar(liste_produit))]
produits_norm <- normalize_text(liste_produit_sorted)

# 5. Normaliser les noms de produits dans le dataset
data_clean <- data_produits_multiples %>%
  mutate(nom_produit_clean = normalize_text(nom_produit))

# 6. Identifier les produits présents dans chaque ligne

system.time({
  df_presence <- data_clean %>%
  mutate(matched_produits = map(nom_produit_clean, function(txt) {
    matched <- character()
    txt_copy <- txt
    for (i in seq_along(produits_norm)) {
      prod <- produits_norm[i]
      regex <- paste0("\\b", prod, "s?\\b")
      if (str_detect(txt_copy, regex)) {
        matched <- c(matched, liste_produit_sorted[i])
        txt_copy <- str_replace_all(txt_copy, regex, " ")
      }
    }
    unique(matched)
  }))
})


# 7. Format long pour comptage
df_long <- df_presence %>%
  unnest(matched_produits) %>%
  rename(nom_prod = matched_produits)

# 8. Compter le nombre de fois qu'un produit apparaît
table_levels_par_prod_apres_split_prod_tranfo <- df_long %>%
  count(nom_prod, name = "nb_levels_peod_transfo") %>%
  complete(nom_prod = liste_produit, fill = list(nb_levels = 0)) %>%
  arrange(nom_prod)

# Affichage
View(table_levels_par_prod_apres_split_prod_tranfo)


```

```{r}
# Trier chaque dataframe par ordre décroissant d'occurrences
liste_dataframes_tries <- map(liste_dataframes, ~ {
  arrange(.x, desc(`Nombre d'occurrences`))
})

```

```{r}
# Ajouter une ligne "Totale" avec la somme des occurrences à chaque dataframe
liste_dataframes_avec_total <- map(liste_dataframes_tries, ~ {
  total <- sum(.x$`Nombre d'occurrences`, na.rm = TRUE)
  bind_rows(.x, tibble(`Nom de produit` = "Totale", `Nombre d'occurrences` = total))
})

```

# XV) Tableau de comptage du nombre de levels par produit avant le split

```{r}
############# Pour les 3 plateformes #############  

# Vecteur contenant tous les levels des 3 plateformes
levels_3_plateformes <- levels(as.factor(combinaison$productName))

#####################################################################

library(stringr)
library(tibble)

# 1. Liste des produits
liste_produit <- c("celeri branche", "pomme de terre", "haricot vert", "clementine",
                   "jus de pomme", "chou fleur", "courgette", "aubergine", "concombre",
                   "nectarine", "lentille", "carotte", "poireau", "abricot", "asperge",
                   "poivron", "potiron", "tomate", "cerise", "fraise", "raisin", "poulet",
                   "laitue", "oignon", "banane", "endive", "poire", "pomme", "boeuf",
                   "prune", "peche", "melon", "kiwi", "lait", "oeuf", "noix", "porc")

# # 2. Liste des levels
# levels_3_plateformes <- c(
#   "veloute de carottes", 
#   "soupe de potiron", 
#   "jus de pommes et de poires", 
#   "gratin de courgettes", 
#   "omelette aux oeufs et oignons", 
#   "haricots verts vapeur", 
#   "puree de pommes de terre",
#   "boeuf;kiwi", 
#   "jus de pommes;poires",
#   "choux fleurs"
# )

library(stringr)
library(dplyr)
library(tibble)
library(purrr)
library(stringi)

# 1. Normalisation texte
normalize_text <- function(x) {
  x %>%
    str_to_lower() %>%
    stri_trans_general("Latin-ASCII") %>%
    gsub("-", " ", ., fixed = TRUE) %>%
    gsub("(s|x)\\b", "", ., perl = TRUE) %>%  # pluriels
    gsub("\\bde\\b|\\bet\\b|\\baux\\b|\\bdes\\b|\\ble\\b|\\bla\\b", "", ., perl = TRUE) %>%
    str_squish()
}

# 2. Trier produits par longueur (plus long d’abord)
liste_produit_sorted <- liste_produit[order(-nchar(liste_produit))]
produits_norm <- normalize_text(liste_produit_sorted)

# 3. Normaliser les levels
df_levels <- tibble(level = levels_3_plateformes) %>%
  mutate(level_clean = normalize_text(level))

# 4. Trouver les produits présents sans doublon interne
df_presence <- df_levels %>%
  mutate(matched_produits = map(level_clean, function(txt) {
    matched <- character()
    txt_copy <- txt
    for (i in seq_along(produits_norm)) {
      prod <- produits_norm[i]
      regex <- paste0("\\b", prod, "s?\\b")
      if (str_detect(txt_copy, regex)) {
        matched <- c(matched, liste_produit_sorted[i])
        # Supprimer le match du texte pour éviter de détecter des sous-mots plus tard
        txt_copy <- str_replace_all(txt_copy, regex, " ")
      }
    }
    unique(matched)
  }))

# 5. Créer une table produit-level (long format)
df_long <- df_presence %>%
  unnest(matched_produits) %>%
  rename(nom_prod = matched_produits)

# 6. Résumer en comptage
table_levels_par_prod_avt_split <- df_long %>%
  count(nom_prod, name = "nb_levels_avt_split") %>%
  complete(nom_prod = liste_produit, fill = list(nb_levels = 0)) %>%
  arrange(nom_prod)


View(table_levels_par_prod_avt_split)
```

```{r}
############# Pour lcagette #############  

# liste_finale_datasets_cagette --> Tout cagette 22-23

##############################################

# Vecteur contenant tous les levels des 3 plateformes
levels_cagette <- levels(as.factor(liste_finale_datasets_cagette$productName))

#####################################################################

library(stringr)
library(tibble)

# 1. Liste des produits
liste_produit <- c("celeri branche", "pomme de terre", "haricot vert", "clementine",
                   "jus de pomme", "chou fleur", "courgette", "aubergine", "concombre",
                   "nectarine", "lentille", "carotte", "poireau", "abricot", "asperge",
                   "poivron", "potiron", "tomate", "cerise", "fraise", "raisin", "poulet",
                   "laitue", "oignon", "banane", "endive", "poire", "pomme", "boeuf",
                   "prune", "peche", "melon", "kiwi", "lait", "oeuf", "noix", "porc")

# # 2. Liste des levels
# levels_cagette <- c(
#   "veloute de carottes", 
#   "soupe de potiron", 
#   "jus de pommes et de poires", 
#   "gratin de courgettes", 
#   "omelette aux oeufs et oignons", 
#   "haricots verts vapeur", 
#   "puree de pommes de terre",
#   "boeuf;kiwi", 
#   "jus de pommes;poires",
#   "choux fleurs"
# )

library(stringr)
library(dplyr)
library(tibble)
library(purrr)
library(stringi)

# 1. Normalisation texte
normalize_text <- function(x) {
  x %>%
    str_to_lower() %>%
    stri_trans_general("Latin-ASCII") %>%
    gsub("-", " ", ., fixed = TRUE) %>%
    gsub("(s|x)\\b", "", ., perl = TRUE) %>%  # pluriels
    gsub("\\bde\\b|\\bet\\b|\\baux\\b|\\bdes\\b|\\ble\\b|\\bla\\b", "", ., perl = TRUE) %>%
    str_squish()
}

# 2. Trier produits par longueur (plus long d’abord)
liste_produit_sorted <- liste_produit[order(-nchar(liste_produit))]
produits_norm <- normalize_text(liste_produit_sorted)

# 3. Normaliser les levels
df_levels <- tibble(level = levels_cagette) %>%
  mutate(level_clean = normalize_text(level))

# 4. Trouver les produits présents sans doublon interne
df_presence <- df_levels %>%
  mutate(matched_produits = map(level_clean, function(txt) {
    matched <- character()
    txt_copy <- txt
    for (i in seq_along(produits_norm)) {
      prod <- produits_norm[i]
      regex <- paste0("\\b", prod, "s?\\b")
      if (str_detect(txt_copy, regex)) {
        matched <- c(matched, liste_produit_sorted[i])
        # Supprimer le match du texte pour éviter de détecter des sous-mots plus tard
        txt_copy <- str_replace_all(txt_copy, regex, " ")
      }
    }
    unique(matched)
  }))

# 5. Créer une table produit-level (long format)
df_long <- df_presence %>%
  unnest(matched_produits) %>%
  rename(nom_prod = matched_produits)

# 6. Résumer en comptage
table_levels_par_prod_avt_split_cagette <- df_long %>%
  count(nom_prod, name = "nb_levels_avt_split") %>%
  complete(nom_prod = liste_produit, fill = list(nb_levels = 0)) %>%
  arrange(nom_prod)

View(table_levels_par_prod_avt_split_cagette)

```


# XVI) Génération des prompts

## a) Développement de la fonction pour générer les prompts

```{r}
detecter_levels_prod_transfor <- function(nom_prod, levels, nb_chunck, taille_chunck) {
  
  total_levels <- length(levels)

  # Création des chunks de taille `taille_chunck` avec gestion du dernier chunk partiel
  chunks <- split(levels, ceiling(seq_along(levels) / taille_chunck))

  # Nombre total de chunks générés
  total_chunks <- length(chunks)

  # Limiter au nb_chunck demandé, mais sans dÃ©passer ceux disponibles
  chunks <- chunks[1:min(nb_chunck, total_chunks)]

  # Prompt de base (dynamique en fonction du produit)
base_prompt <- paste0(
  "Tu es un expert en alimentation et en classification des produits alimentaires.\n\n",
  "Tu reçois une liste de produits à base de ", nom_prod, ".\n",
  "Ta tâche est d’**identifier uniquement les produits transformés** dans cette liste.\n\n",
  "Un **produit est transformé** s’il :\n",
  "- contient **d’autres ingrédients que le/la ", nom_prod, "**\n",
  "- a subi une **transformation culinaire** (cuit, râpé, assaisonné, etc.)\n",
  "- est conditionné ou présenté de manière à indiquer une préparation culinaire\n",
  "- est destiné à un **usage spécifique** impliquant une transformation\n\n",
  "Ignore tous les **produits bruts**, c’est-à-dire :\n",
  "- les produits qui contiennent **seulement ", nom_prod, "**\n",
  "- les produits dont le nom ne mentionne **aucun autre ingrédient ni transformation**\n\n",
  "Retourne uniquement les **noms exacts** des produits transformés de la liste d’origine, sans commentaire ni explication.\n\n",
  "**Le résultat doit être strictement au format suivant (vecteur R) :**\n",
  "`c(\"produit transformé\", \"produit transformé\", ...)`\n",
  "Ne retourne **que** ce vecteur.\n\n",
  "Voici la liste de produits à analyser :\n"
)


  # Générer les prompts complets
  prompts <- lapply(chunks, function(chunk) {
    paste0(base_prompt, paste(chunk, collapse = "\n"))
  })

  # Générer les résultats en appelant gemma3 pour chaque prompt
  resultats <- lapply(prompts, function(p) {
    generate("gemma3", p, stream = FALSE, output = "text")
  })

  return(list(prompts = prompts, resultats = resultats))
}

```

## b) Application de la fonction

```{r}

# Test de la fonction
levels_tomates <- levels(as.factor(data_tomates$productName))
prompts_levels_tomates <- detecter_levels_prod_transfor("tomate", levels_tomates, nb_chunck = 89,
                                         taille_chunck = 50)

# On concatène dans un vecteur  le résultat du dernier chunk
cat(prompts_levels_tomates[[1]])  
cat(prompts_levels_tomates[[2]])  
cat(prompts_levels_tomates[[3]])  
cat(prompts_levels_tomates[[89]])  
```

```{r}

# On stocke tous les prompts
invisible(
  lapply(seq_along(prompts_levels_tomates), function(i) {
    cat("\n")
    cat(prompts_levels_tomates[[i]])
    cat("\n")
  })
)


df <- dput(prompts_levels_tomates, "liste_prompts_complets.txt")
print(df)

save(prompts_levels_tomates, file = "liste_prompts_complets.RData")
```

# XVII) Export du jeu de données

```{r}
write_xlsx(data_tomate,"demonstration/data_tomates.xlsx")
```
