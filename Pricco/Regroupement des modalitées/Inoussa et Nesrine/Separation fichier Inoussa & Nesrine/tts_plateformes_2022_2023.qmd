---
title: "tts_plateformes_2022_2023"
format: html
editor: visual
---

# I) Chargement des bibliothèques nécessaires

```{r,message=FALSE}

# Chargement du package vroom pour lire efficacement des fichiers CSV ou TSV volumineux
library(vroom)

# Chargement du package stringr pour la manipulation avancée de chaînes de caractères
library(stringr)

# Chargement du package stringi pour normaliser les chaînes (ex : suppression d'accents)
library(stringi)

# Chargement du package fs pour gérer les fichiers et chemins de façon robuste (ex : file_exists, path())
library(fs)

# Chargement du méta-package tidyverse, qui regroupe plusieurs packages utiles :
# - ggplot2 : visualisation de données
# - dplyr : manipulation de tableaux de données (data frames)
# - tidyr : transformation de la structure des données (long ↔ wide)
# - readr : lecture rapide de fichiers plats (CSV, etc.)
# - purrr : programmation fonctionnelle (boucles avec map, etc.)
# - tibble : version moderne des data frames
# - stringr : gestion de chaînes de caractères (déjà chargé ci-dessus)
# - forcats : gestion des variables catégorielles (facteurs)
library(tidyverse)

# Chargement explicite du package purrr (déjà inclus dans tidyverse, mais parfois utile de l'importer directement)
library(purrr)

# Chargement du package writexl pour exporter des data frames au format Excel (.xlsx)
library(writexl)

# Chargement explicite du package tibble (également inclus dans tidyverse)
library(tibble)


```

# II) Documentation des variables d'intérêts pour le calcul du prix au kilogramme

| Variable | Définition | Unité |
|----|----|----|
| orderProductPrice | Unités de mesure | Euro |
| orderQuantity | Nombre d'une unité de produit acheté | Sans unité |
| mois | Mois | Mois |
| annee | Année | Année |
| productName | Noms du produit | Sans unité |
| productIsOrganic | Produit est bio | Sans unité |
| productConditioningQuantity | Poids d'une unité de produit | Gramme, kilogramme, pièce |
| productConditioningUnit | Unités de mesure | gramme, kilogramme, pièce |
| distributionZipCode | Code postal | Sans unité |
| plateforme | Plateformes partenaires du projet Pricco | Sans unité |

# III) Importation des fichiers

Ce code lit automatiquement tous les fichiers .csv présents dans un dossier (et ses sous-dossiers), les charge dans une liste, puis nomme chaque élément de cette liste selon le nom de fichier correspondant. C'est une méthode efficace pour manipuler plusieurs jeux de données en une seule opération.

```{r,message=FALSE}
# Définition du dossier racine contenant les fichiers CSV à importer
dossier_racine <- "data/2022-2023"

# Recherche récursive de tous les fichiers CSV dans le dossier spécifié
# `recurse = TRUE` permet de chercher dans les sous-dossiers
# `glob = "*.csv"` filtre uniquement les fichiers ayant l'extension .csv
fichiers <- dir_ls(path = dossier_racine, recurse = TRUE, glob = "*.csv")

# Extraction du nom de chaque fichier (sans chemin ni extension)
# - path_file() extrait le nom du fichier à partir du chemin complet
# - path_ext_remove() retire l'extension (.csv)
noms_fichiers <- path_ext_remove(path_file(fichiers))

# Lecture de chaque fichier CSV avec vroom()
# lapply applique la fonction vroom() à chaque élément de la liste 'fichiers'
datasets <- lapply(fichiers, function(file) vroom(file))

# Attribution des noms de fichiers (sans extension) comme noms des éléments de la liste 'datasets'
names(datasets) <- noms_fichiers

# Affichage de la liste de datasets dans le visualiseur RStudio
View(datasets)

```

# IV) Harmonisation des noms de colonnes de toutes les plateformes

Cette étape permet de préparer les deux jeux de données (ruche_oui_2022 et ruche_oui_2023) en ajoutant une nouvelle colonne appelée productIsOrganic, qui pourra ensuite être renseignée avec des valeurs (ex : TRUE, FALSE, ou d'autres infos sur le caractère bio du produit).

```{r}
# On ajoute une colonne vide (remplie de NA) nommée 'productIsOrganic'
# dans le dataset 'ruche_oui_2022' pour indiquer si un produit est bio
datasets$ruche_oui_2022$productIsOrganic <- NA

# Même opération pour le dataset 'ruche_oui_2023'
datasets$ruche_oui_2023$productIsOrganic <- NA

```

Ce script permet d’harmoniser les structures de données issues de différentes plateformes (Cagette, Ruche, Socleo, CoopCircuit) pour faciliter leur fusion et leur analyse en aval. On standardise les colonnes et ajoute une information sur la provenance (plateforme).

```{r}
# Définition des colonnes à conserver pour les datasets provenant de Cagette
colonne_cagette_a_garder <- c(
  "orderProductPrice", "orderQuantity", "mois", "annee", "productName", 
  "productIsOrganic", "productConditioningQuantity", "productConditioningUnit", 
  "distributionZipCode"
)

# Identification des datasets dont le nom commence par "cagette"
indices_cagette <- startsWith(names(datasets), "cagette")

# Sélection des colonnes souhaitées pour chaque dataset de Cagette
datasets[indices_cagette] <- lapply(datasets[indices_cagette], function(x) {
  select(x, any_of(colonne_cagette_a_garder))
})

# Définition des colonnes à conserver pour les datasets de La Ruche Qui Dit Oui
colonne_ruche_a_garder <- c(
  "price_ttc_item", "nb_item", "mois", "annee", "product_name", "productIsOrganic",
  "weight_raw_item", "quantityunit", "hive_zipcode"
)

# Identification des datasets dont le nom commence par "ruche"
indices_ruche <- startsWith(names(datasets), "ruche")

# Sélection des colonnes souhaitées pour chaque dataset de La Ruche
datasets[indices_ruche] <- lapply(datasets[indices_ruche], function(x) {
  select(x, any_of(colonne_ruche_a_garder))
})

# Définition des colonnes à conserver pour les datasets de Socleo
colonne_socleo_a_garder <- c(
  "value", "quantite_com", "mois", "annee", "name", "is_organic",
  "quantite_cond", "unite_conditionnement", "code_postal"
)

# Identification des datasets dont le nom commence par "socleo"
indices_socleo <- startsWith(names(datasets), "socleo")

# Sélection des colonnes souhaitées pour chaque dataset de Socleo
datasets[indices_socleo] <- lapply(datasets[indices_socleo], function(x) {
  select(x, any_of(colonne_socleo_a_garder))
})

# Définition des colonnes à conserver pour les datasets de CoopCircuit
colonne_coop_circuit_a_garder <- c(
  "price", "quantite_unite", "mois", "annee", "name", "is_organic", 
  "quantite_cond", "conditionnement", "code_postal"
)

# Identification des datasets dont le nom commence par "coop_circuit"
indices_coop_circuit <- startsWith(names(datasets), "coop_circuit")

# Sélection des colonnes souhaitées pour chaque dataset de CoopCircuit
datasets[indices_coop_circuit] <- lapply(datasets[indices_coop_circuit], function(x) {
  select(x, any_of(colonne_coop_circuit_a_garder))
})

# Harmonisation des noms de colonnes pour toutes les plateformes autres que Cagette
# On renomme leurs colonnes pour correspondre à celles de Cagette
datasets[!indices_cagette] <- lapply(datasets[!indices_cagette], function(df) {
  df <- select(df, everything())  # Réorganise les colonnes si nécessaire
  colnames(df) <- colonne_cagette_a_garder  # Applique les noms standardisés
  return(df)
})

# Création d'une nouvelle liste contenant les datasets enrichis d'une colonne "plateforme"
# Cette colonne est extraite du nom de chaque dataset (ex: "ruche_oui_2022" → "ruche")
liste_datasets_final <- lapply(names(datasets), function(nom) {
  df <- datasets[[nom]]
  df$plateforme <- str_split(nom, "_")[[1]][1]  # Extraction de la plateforme à partir du nom
  df
})

# Attribution des noms d’origine aux éléments de la liste finale
names(liste_datasets_final) <- names(datasets)

```

# V) Fusion de tous les jeux de données sauf cagette

Ce code sert à regrouper dans un seul tableau tous les jeux de données hors Cagette, probablement pour des comparaisons ou traitements spécifiques à ces plateformes.

```{r,warning=FALSE}
# Création d'une nouvelle liste ne contenant que les datasets 
# qui ne proviennent PAS de Cagette (on les exclut grâce à !indices_cagette)
liste_datasets_final_sans_cagette <- liste_datasets_final[!indices_cagette]

# Fusion de tous les datasets restants (Ruche, Socleo, CoopCircuit) en un seul data frame
# do.call avec rbind permet d'empiler toutes les lignes des datasets ensemble
combinaison <- do.call(rbind, liste_datasets_final_sans_cagette)

```

# VI) Associer le bon nom de produit

## a) Définition de la liste de produits

```{r}
# Liste des produits alimentaires à rechercher
liste_produits <- c(
  "Clémentine", "Tomate", "Carotte", "Cerise", "Chou fleur",
  "Fraise", "Kiwi", "Lait", "Oeuf", "Poireau", "Poire", "Raisin",
  "Haricot vert", "Noix", "Pomme", "Boeuf", "Porc", "Poulet",
  "Laitue", "Lentille", "Abricot", "Pomme de terre", "Oignon",
  "Courgette", "Aubergine", "Asperge", "Banane", "Poivron",
  "Jus de pomme", "Celeri branche", "Concombre", "Prune",
  "Peche", "Potiron", "Melon", "Endive", "Nectarine")

# Mise en minuscules pour correspondance plus facile
liste_produits <- str_to_lower(liste_produits)

# On supprime les tirets pour correspondance plus facile
liste_produits <- gsub("-", " ", liste_produits, ignore.case = TRUE)

# On supprime les accents pour correspondance plus facile
liste_produits <- stri_trans_general(liste_produits, "Latin-ASCII")

# On ordonne la liste des noms de produits de manière decroissante selon
# le nombre de caractere de chaque mots
ordre <- order(nchar(gsub(" ", "", liste_produits)), decreasing = TRUE)
liste_produits <- liste_produits[ordre]
```

## b) Liste contenant toutes les déclinaisons possibles pour chaque nom de produit

```{r}
# Nettoyer une chaine de caractères (-> ici liste de noms de produits)
nettoyer <- function(x) {
  # Convertit les caractères en minuscules et enlève les accents (ex: "É" devient "e")
  x <- stri_trans_general(str_to_lower(x), "Latin-ASCII")
  # Supprime tous les caractères non alphabétiques (hors a-z et espace)
  x <- str_replace_all(x, "[^a-z ]", "")
  # Supprime les espaces au début et à la fin de chaque chaîne
  x <- trimws(x)
  # Retourne le vecteur nettoyé
  return(x)
}

# Générer des expressions régulières à partir d'un mots ou liste de mots
creer_regex <- function(mots, suffixe = "(e?s)?", collapse = ".*") {
  # Applique la construction de regex à chaque mot ou expression
  sapply(mots, function(terme) {
    # Découpe l'expression en mots individuels
    tokens <- str_split(terme, " ")[[1]]
    # Ajoute le suffixe (par défaut : formes féminines/plurielles) à chaque mot
    regex_tokens <- paste0(tokens, suffixe)
    # Combine les morceaux avec '.*' entre eux pour matcher des variations textuelles
    paste0(regex_tokens, collapse = collapse)
  })
}

# Crée un fichier Excel standard pour permettre l'ajout d'autres déclinaisons
creer_fichier_excel <- function(liste_de_produits, fichier = "autres_declinaisons.xlsx") {
  classeur <- createWorkbook() # Crée un nouveau classeur Excel
  addWorksheet(classeur, "Ajoutez autres déclinaisons") # Ajoute une feuille nommée
  
  # Crée un tableau avec une colonne "Nom de produit" et une colonne vide "Autres déclinaisons"
  data <- data.frame(
    "Nom de produit" = liste_de_produits,
    "Autres déclinaisons" = "",
    check.names = FALSE
  )
  
  # Écrit le tableau dans la feuille Excel à partir de la première ligne avec les noms de colonnes
  writeData(
    classeur, 
    sheet = "Ajoutez autres déclinaisons", 
    x = data, 
    startRow = 1,
    colNames = TRUE
  )
  
  # Calcule le nombre total de lignes (données + en-tête) et de colonnes
  n_rows <- nrow(data) + 1
  n_cols <- ncol(data)
  
  # Calcule des largeurs de colonnes pour lisibilité (+5 caractères de marge)
  largeurs <- nchar(colnames(data)) + 5
  setColWidths(classeur, sheet = "Ajoutez autres déclinaisons", cols = 1:n_cols, widths = largeurs)
  
  # Crée un style pour l'en-tête (texte en gras et taille de police 12)
  header_style <- createStyle(textDecoration = "bold", fontSize = 12)
  addStyle(
    wb = classeur,
    sheet = "Ajoutez autres déclinaisons",
    style = header_style,
    rows = 1,
    cols = 1:n_cols,
    gridExpand = TRUE,
    stack = TRUE
  )
  
  # Crée un style déverrouillé pour permettre la modification des cellules (hors en-tête)
  unlocked_style <- createStyle(locked = FALSE)
  addStyle(
    wb = classeur,
    sheet = "Ajoutez autres déclinaisons",
    style = unlocked_style,
    rows = 2:n_rows,
    cols = 1:n_cols,
    gridExpand = TRUE,
    stack = TRUE
  )
  
  # Protège la feuille tout en autorisant la sélection des cellules verrouillées et déverrouillées
  protectWorksheet(
    wb = classeur,
    sheet = "Ajoutez autres déclinaisons",
    protect = TRUE,
    lockSelectingLockedCells = FALSE,
    lockSelectingUnlockedCells = FALSE
  )
  
  # Enregistre le fichier Excel sous le nom spécifié (en écrasant s’il existe)
  saveWorkbook(classeur, fichier, overwrite = TRUE)
}


# Fonction pour extraire toutes les déclinaisons des noms de produits à partir d'un dataset et d’un fichier externe facultatif
trouver_declinaisons_nom_produit <- 
  function(dataset, col_produit, ls_produit, regex, fichier = NULL) {
  # Nettoie les noms de produits dans la colonne spécifiée du dataset
  noms_des_produits <- nettoyer(dataset[[col_produit]])
  # Supprime les doublons parmi les noms nettoyés
  noms_des_produits_uniques <- unique(noms_des_produits)
  # Pour chaque expression régulière, extrait les correspondances dans les noms de produits uniques
  liste_declinaisons <- sapply(seq_along(regex), function(i) {
    extractions <- str_extract(noms_des_produits_uniques, regex[i]) # Applique la regex
    extractions <- extractions[!is.na(extractions) & extractions != ""] # Filtre les vides ou NA
    unique(extractions) # Supprime les doublons dans les extractions
  }, simplify = FALSE)
  
  # Donne à chaque élément de la liste le nom du produit correspondant
  names(liste_declinaisons) <- ls_produit
  
  # Si un fichier externe est fourni, ajouter les déclinaisons supplémentaires
  if(!is.null(fichier)==TRUE){
    fichier <- na.omit(fichier) # Supprime les lignes contenant des NA
    fichier[["Nom de produit"]] <- nettoyer(fichier[["Nom de produit"]]) # Nettoie les noms de produits du fichier
    sapply(fichier[["Nom de produit"]], function(prod){
      res <- pull(fichier[fichier[["Nom de produit"]]==prod,"Autres déclinaisons"]) # Récupère les déclinaisons associées au produit
      declinaisons_suppl <- unlist(str_split(res, ";")) # Sépare les déclinaisons par ";"
      liste_declinaisons[[prod]] <<- unique(c(liste_declinaisons[[prod]], declinaisons_suppl)) # Ajoute les déclinaisons à la liste existante en supprimant les doublons
    })
  }
  # Retourne la liste complète des déclinaisons
  return(liste_declinaisons)
}
```

## c) Développement de la fonction split

```{r}
#  Fonction split par nom de produit
separation_fichiers <- function(data, liste_produits, liste_declinai_noms_produits) {

  #### Étape 0 : Ajout et nettoyage de la colonne `name_clean` dans `data`
  data <- data %>%
    mutate(
      name_clean = productName %>%
        str_to_lower() %>%
        stri_trans_general("Latin-ASCII") %>%
        gsub("-", " ", ., ignore.case = TRUE)
    )

  #### Étape 1 : On extrait les levels des produits
  levels_produits <- levels(as.factor(data$name_clean))

  #### Étape 2 : Création de la matrice de présence
  matrice_presence <- sapply(liste_declinai_noms_produits, function(declinaisons) {
    sapply(levels_produits, function(level) {
      any(str_detect(level, fixed(declinaisons))) * 1
    })
  })

  # Transposition pour avoir les produits en colonnes
  matrice_presence <- t(matrice_presence)

  # Calcul du nombre de correspondances pour chaque level
  nb_variantes_noms <- colSums(matrice_presence)

  # Ajouter cette ligne en bas de la matrice
  matrice_presence <- rbind(matrice_presence, nb_variantes_noms)

  #### Étape 3 : Identifier les noms qui correspondent à un seul produit
  levels_uniques <- names(nb_variantes_noms[nb_variantes_noms == 1])

  # On garde uniquement les colonnes de la matrice où une seule correspondance existe
  matrice_uniques <- matrice_presence[-nrow(matrice_presence), levels_uniques, drop = FALSE]

  #### Étape 4 : Créer un vecteur nom_produit proprement
  vecteur_nom_produit <- sapply(levels_uniques, function(level) {
    idx <- which(matrice_uniques[, level] == 1)
    if (length(idx) == 1) {
      return(liste_produits[idx])
    } else {
      return(NA)
    }
  }, USE.NAMES = TRUE)

  vecteur_nom_produit <- vecteur_nom_produit[!is.na(vecteur_nom_produit)]

  # Créer le dataframe de correspondance
  df_correspondance <- data.frame(
    name_clean = names(vecteur_nom_produit),
    nom_produit = unname(vecteur_nom_produit),
    stringsAsFactors = FALSE
  )

  #### Étape 5 : Générer data_ok en ajoutant nom_produit
  data_ok <- data %>%
    filter(name_clean %in% df_correspondance$name_clean) %>%
    left_join(df_correspondance, by = "name_clean")

  #### Étape 6 : Extraire les noms avec 0 ou plusieurs correspondances
  levels_pas_ok <- names(nb_variantes_noms[nb_variantes_noms != 1])

  matrice_pas_ok <- matrice_presence[-nrow(matrice_presence), levels_pas_ok, drop = FALSE]

  vecteur_nom_pas_ok <- sapply(levels_pas_ok, function(level) {
    idx <- which(matrice_pas_ok[, level] == 1)
    if (length(idx) == 0) {
      return(NA)
    } else {
      return(paste(liste_produits[idx], collapse = ";"))
    }
  }, USE.NAMES = TRUE)

  df_correspondance_pas_ok <- data.frame(
    name_clean = names(vecteur_nom_pas_ok),
    nom_produit = unname(vecteur_nom_pas_ok),
    stringsAsFactors = FALSE
  )

  #### Étape 7 : Générer data_pas_ok
  data_pas_ok <- data %>%
    filter(name_clean %in% df_correspondance_pas_ok$name_clean) %>%
    left_join(df_correspondance_pas_ok, by = "name_clean")

  #### Étape 8 : Identifier les lignes avec plusieurs noms dans data_pas_ok
  data_ambigus <- data_pas_ok %>%
    filter(str_detect(nom_produit, ";"))

  #### Étape 9 : Nettoyage des noms emboîtés
  data_ambigus_clean <- data_ambigus %>%
    rowwise() %>%
    mutate(
      noms_list = list(str_split(nom_produit, ";")[[1]] %>% str_trim())
    ) %>%
    mutate(
      noms_clean = list({
        noms <- noms_list
        noms[!sapply(noms, function(x) any(noms != x & str_detect(noms, fixed(x))))]
      })
    ) %>%
    mutate(
      nom_produit_new = ifelse(length(noms_clean) == 1, noms_clean[[1]], paste(noms_clean, collapse = ";"))
    ) %>%
    ungroup()

  #### Étape 10 : Extraire les lignes devenues "uniques" après nettoyage
  data_deplaces <- data_ambigus_clean %>%
    filter(!str_detect(nom_produit_new, ";")) %>%
    select(-nom_produit, -noms_list, -noms_clean) %>%
    rename(nom_produit = nom_produit_new)

  #### Étape 11 : Mettre à jour data_ok
  data_ok <- bind_rows(data_ok, data_deplaces)

  #### Étape 12 : Mettre à jour data_pas_ok sans les lignes déplacées
  data_pas_ok <- data_pas_ok %>%
    filter(!(name_clean %in% data_deplaces$name_clean))

  return(list(data_ok = data_ok, data_pas_ok = data_pas_ok))
}
```

## d) Application de la fonction split

```{r,message=FALSE,warning=FALSE}

# Test de la fonction : Fichier coop circuit 2021
system.time({ 
  resultats_2 <- separation_fichiers(
  data = combinaison,
  liste_produits = liste_produits,
  liste_declinai_noms_produits = final_declinaisons
)})


# On regarde séparemment le data_ok et data_pas_ok
data_prod_tries <- resultats_2$data_ok
data_prod_pas_tries <- resultats_2$data_pas_ok

```

# VII) Fusion de tous les fichiers de cagette

```{r,warning=FALSE}

# On extrait les tables cagette dans une liste
liste_datasets_cagette <- liste_datasets_final[indices_cagette]
```

```{r,warning=FALSE}
################## On fusionne les tables pommes ensemble

# Étape 1 : renommer les éléments pour grouper
noms_groupes <- sub("part_\\d+_", "", names(liste_datasets_cagette))

# Étape 2 : fusionner les data.frames par groupe
liste_datasets_cagette <- lapply(
  split(liste_datasets_cagette, noms_groupes),
  function(groupe) do.call(rbind, groupe)
)

liste_datasets_cagette[["cagette_Pomme_2022"]] <- unique(liste_datasets_cagette[["cagette_Pomme_2022"]])

liste_datasets_cagette[["cagette_Pomme_2023"]] <- unique(liste_datasets_cagette[["cagette_Pomme_2023"]])


```

```{r}
#################### On ajoute la nouvelle colonne nom_produit à toutes les tables cagette
# Liste des produits
liste_produits_alimentaires <- c(
  "Abricot", "Asperge", "Aubergine","Banane","Carotte","Cerise","Chou fleur",
  "Clémentine", "Concombre","Courgette","Céleri branche","Endive","Fraise",
  "Haricot vert","Kiwi","Laitue","Melon","Nectarine","Oignon","Poire",
  "Poireau","Poivron",
  "Pomme de terre","Pomme","Potiron","Prune","Pêche","Raisin","Tomate")

# Nettoyer les noms : minuscules + suppression des accents + remplacement des espaces par _
nettoyer_nom <- function(x) {
  x %>%
    tolower() %>%
    stri_trans_general("Latin-ASCII") %>%
    gsub("[^a-z0-9]+", " ", .) %>%
    gsub("_+$", "", .) %>%
    gsub("^_+", "", .)
}

# Noms nettoyés des produits
produits_nettoyes <- sapply(liste_produits_alimentaires, nettoyer_nom, USE.NAMES = FALSE)

# Création d'une table de correspondance entre produits nettoyés et noms originaux
produits_df <- data.frame(
  produit_clean = produits_nettoyes,
  produit_label = tolower(liste_produits_alimentaires),
  stringsAsFactors = FALSE
)

# Ajouter la colonne nom_produit dans chaque data frame
liste_datasets_cagette_nettoyee <- lapply(names(liste_datasets_cagette), function(nom_df) {
  df <- liste_datasets_cagette[[nom_df]]
  
  # Extraire le nom du produit dans le nom de la table
  produit_nom_match <- sub("cagette_(.*)_20[0-9]{2}", "\\1", nom_df)
  
  # Nettoyage de ce nom pour le faire correspondre
  produit_nom_clean <- nettoyer_nom(produit_nom_match)
  
  # Recherche du nom d'origine
  produit_label <- produits_df$produit_label[match(produit_nom_clean, produits_df$produit_clean)]
  
  # Ajoute directement le nom nettoyé (sans accents)
  df$nom_produit <- produits_df$produit_clean[match(produit_nom_clean, produits_df$produit_clean)]

  
  return(df)
})

# Réattribution des noms à la liste
names(liste_datasets_cagette_nettoyee) <- names(liste_datasets_cagette)

```

```{r}
# On fusionne toutes les tables de cagette en une seule
liste_finale_datasets_cagette <- do.call(rbind, liste_datasets_cagette_nettoyee)
```


# VIII) On vérifie la pertinence des données déjà classées par les fournisseurs 

```{r}

# On regarde toutes les déclinaisons de noms de produit possibles pour les fichiers cagette
vect_decli_cagette <- trouver_declinaisons_nom_produit(
    dataset = liste_finale_datasets_cagette,
    col_produit = "productName",
    ls_produit = liste_produits,
    regex = regex
  )
```


```{r}
# On attribue le bon nom de produit de la liste des 37 à chaque ligne 

# On retire la colonne contenant le type de produit 
liste_finale_datasets_cagette <- liste_finale_datasets_cagette |> select(-c(11))

# Test de la fonction : Fichier coop circuit 2021
system.time({ 
  liste_cagette_trie_et_pas_trie <- separation_fichiers(
  data = liste_finale_datasets_cagette,
  liste_produits = liste_produits,
  liste_declinai_noms_produits = vect_decli_cagette
)})


# On regarde séparemment le data_ok et data_pas_ok
cagette_prod_tries <- liste_cagette_trie_et_pas_trie$data_ok
cagette_prod_pas_tries <- liste_cagette_trie_et_pas_trie$data_pas_ok

```


# IX) Fusion de tous les fichiers de produits triés issus de toutes les plateformes

```{r}
# On supprime la colonne name_clean de data_prod_tries
data_prod_tries <- data_prod_tries |> select(-c("name_clean"))

# On supprime la colonne name_clean de cagette_prod_tries
cagette_prod_tries <- cagette_prod_tries |> select(-c("name_clean"))

# On fusionne toutes les tables de cagette en une seule
datasets_tts_plateformes_prod_tries <- rbind(cagette_prod_tries,data_prod_tries)

```


# X) Fusion des fichiers de produits pas triés en un seul 

```{r}

# On fusionne toutes les tables de cagette en une seule
data_prod_pas_tries_tts_platatefor <- rbind(cagette_prod_pas_tries,data_prod_pas_tries)

```

# XI) Indicateur de pureté pour les produits triés

```{r}

# Extraire les levels (uniques)
levels_productName <- unique(datasets_tts_plateformes_prod_tries$productName)
levels_nom_produit <- unique(datasets_tts_plateformes_prod_tries$nom_produit)

# Indicateur de pureté pour les produits triés
compter_occurrences_exclusives <- function(df, col_productName = "productName", col_nom_produit = "nom_produit") {
  # Étape 1 : trier les noms_produit du plus long au plus court (pour priorité aux plus spécifiques)
  levels_nom_produit <- unique(df[[col_nom_produit]])
  levels_nom_produit <- levels_nom_produit[order(nchar(levels_nom_produit), decreasing = TRUE)]
  
  # Étape 2 : récupérer tous les productName uniques
  all_product_names <- unique(df[[col_productName]])
  
  # Étape 3 : initialiser les noms déjà utilisés
  noms_assignés <- rep(FALSE, length(all_product_names))
  names(noms_assignés) <- all_product_names
  
  # Étape 4 : construire les tableaux
  resultats <- map(levels_nom_produit, function(nom_produit) {
    # Construire la regex pluriel + imbriqué
    mots <- str_split(nom_produit, " ")[[1]]
    mots_regex <- paste0("(", mots, ")(s|x)?")
    motif <- paste(mots_regex, collapse = "[- ]?")
    
    # Filtrer uniquement les noms encore disponibles
    names_disponibles <- all_product_names[!noms_assignés]
    
    # Compter les occurrences
    nb_occ <- str_count(tolower(names_disponibles), regex(motif, ignore_case = TRUE))
    
    # Conserver ceux avec une correspondance
    matched_names <- names_disponibles[nb_occ > 0]
    matched_counts <- nb_occ[nb_occ > 0]
    
    # Marquer ces noms comme assignés
    noms_assignés[matched_names] <<- TRUE
    
    # Retourner le tibble
    tibble(
      !!paste0("levels_", str_replace_all(nom_produit, " ", "_")) := matched_names,
      !!paste0("nb_occurrence_", str_replace_all(nom_produit, " ", "_")) := matched_counts
    )
  }) |> set_names(levels_nom_produit)
  
  return(resultats)
}


# On teste la fonction 
liste_table_indi_purete_prod_trie <- compter_occurrences_from_levels(levels_productName, levels_nom_produit)


```


# XII) On sépare en 37 tables

## a) Développement de la fonction pour split en 37 tables

```{r}

split_data_ok_par_produit <- function(data_ok) {
  # Vérification de la présence de la colonne nom_produit
  if (!"nom_produit" %in% colnames(data_ok)) {
    stop("La colonne 'nom_produit' est absente de data_ok")
  }

  # Découpage automatique en liste de data frames, un par produit
  liste_data_par_produit <- split(data_ok, data_ok$nom_produit)

  return(liste_data_par_produit)
}

```

## b) Application de la fonction

```{r}
# Test de la fonction : data_ok de coop circuit 2021
liste_tables_37_produit_bruts <- split_data_ok_par_produit(datasets_tts_plateformes_prod_tries)

# Accéder au sous-dataframe pour le produit "pomme"
data_tomate <- liste_tables_37_produit_bruts[["tomate"]]

# Voir tous les noms de produits
names(data_tomate)

```
