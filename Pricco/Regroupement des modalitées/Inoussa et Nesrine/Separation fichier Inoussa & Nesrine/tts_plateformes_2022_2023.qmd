---
title: "tts_plateformes_2022_2023"
format: html
editor: visual
---

# I) Chargement des bibliothèques nécessaires

```{r,message=FALSE}

# Pour lire les fichiers CSV
library(vroom)

# Pour manipuler et détecter les chaînes de caractères
library(stringr)

# Pour gérer les accents et normaliser les chaînes
library(stringi)
library(fs)

# Le tidyverse est un méta-package qui regroupe plusieurs packages R
# utiles pour la manipulation, la transformation, et la visualisation de données :
# - ggplot2 : pour la visualisation
# - dplyr : pour la manipulation de données (filtrer, trier, grouper...)
# - tidyr : pour le reshaping (pivot_longer, pivot_wider, etc.)
# - readr : pour lire des fichiers plats (CSV, TSV...)
# - purrr : pour la programmation fonctionnelle (map, etc.)
# - tibble : pour manipuler des data frames modernes
# - stringr : pour manipuler des chaînes de caractères
# - forcats : pour manipuler des facteurs

library(tidyverse)
library(openxlsx) # Creer un fichier excel avec plus d'option possible
library(readxl)
library(purrr)
# Export des fichiers au format Excel 
library(writexl)

library(tibble)

```

# II) Documentation des variables d'intérêts pour le calcul du prix au kilogramme

| Variable | Définition | Unité |
|----|----|----|
| orderProductPrice | Unités de mesure | Euro |
| orderQuantity | Nombre d'une unité de produit acheté | Sans unité |
| mois | Mois | Mois |
| annee | Année | Année |
| productName | Noms du produit | Sans unité |
| productIsOrganic | Produit est bio | Sans unité |
| productConditioningQuantity | Poids d'une unité de produit | Gramme, kilogramme, pièce |
| productConditioningUnit | Unités de mesure | gramme, kilogramme, pièce |
| distributionZipCode | Code postal | Sans unité |
| plateforme | Plateformes partenaires du projet Pricco | Sans unité |

# III) Importation des fichiers

```{r,message=FALSE}
dossier_racine <- "data/2022-2023"
fichiers <- dir_ls(path = dossier_racine, recurse = TRUE, glob = "*.csv")
noms_fichiers <- path_ext_remove(path_file(fichiers))
datasets <- lapply(fichiers, function(file) vroom(file))
names(datasets) <- noms_fichiers
View(datasets)
```

# IV) Harmonisation des noms de colonnes de toutes les plateformes

```{r}
# On ajoute la colonne pour le bio 

datasets$ruche_oui_2022$productIsOrganic <- NA
datasets$ruche_oui_2023$productIsOrganic <- NA
```

```{r}
# Colonne de cagette à garder 
colonne_cagette_a_garder <- c(
  "orderProductPrice", "orderQuantity", "mois", "annee", "productName", 
  "productIsOrganic", "productConditioningQuantity", "productConditioningUnit", 
  "distributionZipCode")
indices_cagette <- startsWith(names(datasets), "cagette")

datasets[indices_cagette] <- lapply(datasets[indices_cagette], function(x) {
  select(x, any_of(colonne_cagette_a_garder))
})


# Colonne de ruche qui dit oui à garder 
colonne_ruche_a_garder <- c(
  "price_ttc_item","nb_item","mois","annee", "product_name","productIsOrganic",
  "weight_raw_item", "quantityunit", "hive_zipcode")

indices_ruche <- startsWith(names(datasets), "ruche")

datasets[indices_ruche] <- lapply(datasets[indices_ruche], function(x) {
  select(x, any_of(colonne_ruche_a_garder))
})

# Colonne de socleo qui dit oui à garder 
colonne_socleo_a_garder <- c(
  "value", "quantite_com","mois","annee","name","is_organic","quantite_cond",
  "unite_conditionnement", "code_postal")

indices_socleo <- startsWith(names(datasets), "socleo")

datasets[indices_socleo] <- lapply(datasets[indices_socleo], function(x) {
  select(x, any_of(colonne_socleo_a_garder))
})

# Colonne de coop circuit qui dit oui à garder 
colonne_coop_circuit_a_garder <- c(
  "price", "quantite_unite","mois", "annee", "name", "is_organic", "quantite_cond",
  "conditionnement","code_postal") 

indices_coop_circuit <- startsWith(names(datasets), "coop_circuit")

datasets[indices_coop_circuit] <- lapply(datasets[indices_coop_circuit], function(x) {
  select(x, any_of(colonne_coop_circuit_a_garder))
})

# Renommer toutes les noms de colonnes des bases aux noms de celui de cagette
datasets[!indices_cagette] <- lapply(datasets[!indices_cagette], function(df) {
  df <- select(df, everything())
  colnames(df) <- colonne_cagette_a_garder
  return(df)
})

liste_datasets_final <- lapply(names(datasets), function(nom) {
  df <- datasets[[nom]]
  df$plateforme <- str_split(nom, "_")[[1]][1]
  df
})

names(liste_datasets_final) <- names(datasets)

```

# V) Fusion de tous les jeux de données sauf cagette

```{r,warning=FALSE}
liste_datasets_final_sans_cagette <- liste_datasets_final[!indices_cagette]

combinaison <- do.call(rbind, liste_datasets_final_sans_cagette)
```

# VI) Séparation des fichiers par produit

## a) Définition de la liste de produits

```{r}
# Liste des produits alimentaires à rechercher
liste_produits <- c(
  "Clémentine", "Tomate", "Carotte", "Cerise", "Chou fleur",
  "Fraise", "Kiwi", "Lait", "Oeuf", "Poireau", "Poire", "Raisin",
  "Haricot vert", "Noix", "Pomme", "Boeuf", "Porc", "Poulet",
  "Laitue", "Lentille", "Abricot", "Pomme de terre", "Oignon",
  "Courgette", "Aubergine", "Asperge", "Banane", "Poivron",
  "Jus de pomme", "Celeri branche", "Concombre", "Prune",
  "Peche", "Potiron", "Melon", "Endive", "Nectarine")

# Mise en minuscules pour correspondance plus facile
liste_produits <- str_to_lower(liste_produits)

# On supprime les tirets pour correspondance plus facile
liste_produits <- gsub("-", " ", liste_produits, ignore.case = TRUE)

# On supprime les accents pour correspondance plus facile
liste_produits <- stri_trans_general(liste_produits, "Latin-ASCII")

# On ordonne la liste des noms de produits de manière decroissante selon
# le nombre de caractere de chaque mots
ordre <- order(nchar(gsub(" ", "", liste_produits)), decreasing = TRUE)
liste_produits <- liste_produits[ordre]
```

## b) Liste contenant toutes les déclinaisons possibles pour chaque nom de produit

```{r}
# Nettoyer une chaine de caractères (-> ici liste de noms de produits)
nettoyer <- function(x) {
  x <- stri_trans_general(str_to_lower(x), "Latin-ASCII") 
  x <- str_replace_all(x, "[^a-z ]", "")
  x <- trimws(x)
  return(x)
}

# Générer des expressions régulières à partir d'un mots ou liste de mots
creer_regex <- function(mots, suffixe = "(e?s)?", collapse = ".*") {
  sapply(mots, function(terme) {
    tokens <- str_split(terme, " ")[[1]] 
    regex_tokens <- paste0(tokens, suffixe)
    paste0(regex_tokens, collapse = collapse)
  })
}

# Creer un fichier excel standar permettant de rajoutter d'autres d'éclinaisons
creer_fichier_excel <- function(liste_de_produits, fichier = "autres_declinaisons.xlsx") {
  classeur <- createWorkbook() # Creer un classeur
  addWorksheet(classeur, "Ajoutez autres déclinaisons") # Ajouter une feuille nommée
  # Dataframe qui sera écrit dans la feuille excel
  data <- data.frame(
    "Nom de produit" = liste_de_produits,
    "Autres déclinaisons" = "",
    check.names = FALSE
  )
  # Ecriture du dataframe dans la feuille excel
  writeData(
    classeur, 
    sheet = "Ajoutez autres déclinaisons", 
    x = data, 
    startRow = 1,  # Début d'écriture à la première ligne
    colNames = TRUE # Considérer la première ligne comme le nom des colonnes
  )
  
  # Nombre de ligne et colonne du dataframe
  n_rows <- nrow(data) + 1 # Considérer la ligne des colonnes de données de la feuille excel
  n_cols <- ncol(data)
  
  # Ajouter de l'espace dans le nom des colonnes(Rendre plus lisible) 
  largeurs <- nchar(colnames(data)) + 5  # +5 pour un peu d’espace
  setColWidths(classeur, sheet = "Ajoutez autres déclinaisons", cols = 1:n_cols, widths = largeurs)
  
  # Mettre en gras et augmenter la taille des noms de colonnes de la feuille 
  header_style <- createStyle(textDecoration = "bold", fontSize = 12)
  addStyle(
    wb = classeur,
    sheet = "Ajoutez autres déclinaisons",
    style = header_style,
    rows = 1,
    cols = 1:n_cols,
    gridExpand = TRUE,
    stack = TRUE
  )
  # Par défaut les cellules excels sont vérouillées (Déverouiller pour tous les autres lignes)
  unlocked_style <- createStyle(locked = FALSE)
  addStyle(
    wb = classeur,
    sheet = "Ajoutez autres déclinaisons",
    style = unlocked_style,
    rows = 2:n_rows,
    cols = 1:n_cols,
    gridExpand = TRUE,
    stack = TRUE
  )
  # Appliquer donc la protection que sur les noms de colonnes de la feuille 
  protectWorksheet(
    wb = classeur,
    sheet = "Ajoutez autres déclinaisons",
    protect = TRUE,
    # Autoriser la sélection sur toutes les cellules (locked ou unlocked)
    lockSelectingLockedCells = FALSE,
    lockSelectingUnlockedCells = FALSE
  )
  
  saveWorkbook(classeur, fichier, overwrite = TRUE)
}

# Extraires des noms de produits toutes les declinaisons des noms de la liste de produit
trouver_declinaisons_nom_produit <- 
  function(dataset, col_produit, ls_produit, regex, fichier = NULL) {
  # Extraction des noms uniques de produits
  noms_des_produits <- nettoyer(dataset[[col_produit]])
  noms_des_produits_uniques <- unique(noms_des_produits)
  # Extraction des déclinaisons par produit
  liste_declinaisons <- sapply(seq_along(regex), function(i) {
    extractions <- str_extract(noms_des_produits_uniques, regex[i])
    extractions <- extractions[!is.na(extractions) & extractions != ""]
    unique(extractions)
  }, simplify = FALSE)

  names(liste_declinaisons) <- ls_produit
  
  # Ajouter d'autres déclinaisons extérieurs 
  if(!is.null(fichier)==TRUE){
    fichier <- na.omit(fichier)
    fichier[["Nom de produit"]] <- nettoyer(fichier[["Nom de produit"]])
    sapply(fichier[["Nom de produit"]], function(prod){
      res <- pull(fichier[fichier[["Nom de produit"]]==prod,"Autres déclinaisons"])
      declinaisons_suppl <- unlist(str_split(res, ";"))
      liste_declinaisons[[prod]] <<- unique(c(liste_declinaisons[[prod]], declinaisons_suppl))
    })
  }
  return(liste_declinaisons)
}
```

```{r}
# Creer les expressions reguliere de la liste des noms de produits
regex <- creer_regex(liste_produits) 

# Creaction du fichier excel en question permettant de rajouter dautres déclinaisons
# creer_fichier_excel(liste_produits)

# Declinaison obtenues de manière automatique
exemple <- read_excel("autres_declinaisons.xlsx")

# Declinaison obtenues de manière automatique
final_declinaisons <- trouver_declinaisons_nom_produit(
    dataset = combinaison,
    col_produit = "productName",
    ls_produit = liste_produits,
    regex = regex,
    fichier = exemple
  )

```

## c) Développement de la fonction split

```{r}
#  Fonction split par nom de produit
separation_fichiers <- function(data, liste_produits, liste_declinai_noms_produits) {

  #### Étape 0 : Ajout et nettoyage de la colonne `name_clean` dans `data`
  data <- data %>%
    mutate(
      name_clean = productName %>%
        str_to_lower() %>%
        stri_trans_general("Latin-ASCII") %>%
        gsub("-", " ", ., ignore.case = TRUE)
    )

  #### Étape 1 : On extrait les levels des produits
  levels_produits <- levels(as.factor(data$name_clean))

  #### Étape 2 : Création de la matrice de présence
  matrice_presence <- sapply(liste_declinai_noms_produits, function(declinaisons) {
    sapply(levels_produits, function(level) {
      any(str_detect(level, fixed(declinaisons))) * 1
    })
  })

  # Transposition pour avoir les produits en colonnes
  matrice_presence <- t(matrice_presence)

  # Calcul du nombre de correspondances pour chaque level
  nb_variantes_noms <- colSums(matrice_presence)

  # Ajouter cette ligne en bas de la matrice
  matrice_presence <- rbind(matrice_presence, nb_variantes_noms)

  #### Étape 3 : Identifier les noms qui correspondent à un seul produit
  levels_uniques <- names(nb_variantes_noms[nb_variantes_noms == 1])

  # On garde uniquement les colonnes de la matrice où une seule correspondance existe
  matrice_uniques <- matrice_presence[-nrow(matrice_presence), levels_uniques, drop = FALSE]

  #### Étape 4 : Créer un vecteur nom_produit proprement
  vecteur_nom_produit <- sapply(levels_uniques, function(level) {
    idx <- which(matrice_uniques[, level] == 1)
    if (length(idx) == 1) {
      return(liste_produits[idx])
    } else {
      return(NA)
    }
  }, USE.NAMES = TRUE)

  vecteur_nom_produit <- vecteur_nom_produit[!is.na(vecteur_nom_produit)]

  # Créer le dataframe de correspondance
  df_correspondance <- data.frame(
    name_clean = names(vecteur_nom_produit),
    nom_produit = unname(vecteur_nom_produit),
    stringsAsFactors = FALSE
  )

  #### Étape 5 : Générer data_ok en ajoutant nom_produit
  data_ok <- data %>%
    filter(name_clean %in% df_correspondance$name_clean) %>%
    left_join(df_correspondance, by = "name_clean")

  #### Étape 6 : Extraire les noms avec 0 ou plusieurs correspondances
  levels_pas_ok <- names(nb_variantes_noms[nb_variantes_noms != 1])

  matrice_pas_ok <- matrice_presence[-nrow(matrice_presence), levels_pas_ok, drop = FALSE]

  vecteur_nom_pas_ok <- sapply(levels_pas_ok, function(level) {
    idx <- which(matrice_pas_ok[, level] == 1)
    if (length(idx) == 0) {
      return(NA)
    } else {
      return(paste(liste_produits[idx], collapse = ";"))
    }
  }, USE.NAMES = TRUE)

  df_correspondance_pas_ok <- data.frame(
    name_clean = names(vecteur_nom_pas_ok),
    nom_produit = unname(vecteur_nom_pas_ok),
    stringsAsFactors = FALSE
  )

  #### Étape 7 : Générer data_pas_ok
  data_pas_ok <- data %>%
    filter(name_clean %in% df_correspondance_pas_ok$name_clean) %>%
    left_join(df_correspondance_pas_ok, by = "name_clean")

  #### Étape 8 : Identifier les lignes avec plusieurs noms dans data_pas_ok
  data_ambigus <- data_pas_ok %>%
    filter(str_detect(nom_produit, ";"))

  #### Étape 9 : Nettoyage des noms emboîtés
  data_ambigus_clean <- data_ambigus %>%
    rowwise() %>%
    mutate(
      noms_list = list(str_split(nom_produit, ";")[[1]] %>% str_trim())
    ) %>%
    mutate(
      noms_clean = list({
        noms <- noms_list
        noms[!sapply(noms, function(x) any(noms != x & str_detect(noms, fixed(x))))]
      })
    ) %>%
    mutate(
      nom_produit_new = ifelse(length(noms_clean) == 1, noms_clean[[1]], paste(noms_clean, collapse = ";"))
    ) %>%
    ungroup()

  #### Étape 10 : Extraire les lignes devenues "uniques" après nettoyage
  data_deplaces <- data_ambigus_clean %>%
    filter(!str_detect(nom_produit_new, ";")) %>%
    select(-nom_produit, -noms_list, -noms_clean) %>%
    rename(nom_produit = nom_produit_new)

  #### Étape 11 : Mettre à jour data_ok
  data_ok <- bind_rows(data_ok, data_deplaces)

  #### Étape 12 : Mettre à jour data_pas_ok sans les lignes déplacées
  data_pas_ok <- data_pas_ok %>%
    filter(!(name_clean %in% data_deplaces$name_clean))

  return(list(data_ok = data_ok, data_pas_ok = data_pas_ok))
}
```

## d) Application de la fonction split

```{r,message=FALSE,warning=FALSE}

# Test de la fonction : Fichier coop circuit 2021
system.time({ 
  resultats_2 <- separation_fichiers(
  data = combinaison,
  liste_produits = liste_produits,
  liste_declinai_noms_produits = final_declinaisons
)})


# On regarde séparemment le data_ok et data_pas_ok
data_prod_tries <- resultats_2$data_ok
data_prod_pas_tries <- resultats_2$data_pas_ok

```

# VII) Fusion de tous les fichiers de cagette

```{r,warning=FALSE}

# On extrait les tables cagette dans une liste
liste_datasets_cagette <- liste_datasets_final[indices_cagette]
```

```{r,warning=FALSE}
################## On fusionne les tables pommes ensemble

# Étape 1 : renommer les éléments pour grouper
noms_groupes <- sub("part_\\d+_", "", names(liste_datasets_cagette))

# Étape 2 : fusionner les data.frames par groupe
liste_datasets_cagette <- lapply(
  split(liste_datasets_cagette, noms_groupes),
  function(groupe) do.call(rbind, groupe)
)

liste_datasets_cagette[["cagette_Pomme_2022"]] <- unique(liste_datasets_cagette[["cagette_Pomme_2022"]])

liste_datasets_cagette[["cagette_Pomme_2023"]] <- unique(liste_datasets_cagette[["cagette_Pomme_2023"]])


```

```{r}
#################### On ajoute la nouvelle colonne nom_produit à toutes les tables cagette
# Liste des produits
liste_produits_alimentaires <- c(
  "Abricot", "Asperge", "Aubergine","Banane","Carotte","Cerise","Chou fleur",
  "Clémentine", "Concombre","Courgette","Céleri branche","Endive","Fraise",
  "Haricot vert","Kiwi","Laitue","Melon","Nectarine","Oignon","Poire",
  "Poireau","Poivron",
  "Pomme de terre","Pomme","Potiron","Prune","Pêche","Raisin","Tomate")

# Nettoyer les noms : minuscules + suppression des accents + remplacement des espaces par _
nettoyer_nom <- function(x) {
  x %>%
    tolower() %>%
    stri_trans_general("Latin-ASCII") %>%
    gsub("[^a-z0-9]+", " ", .) %>%
    gsub("_+$", "", .) %>%
    gsub("^_+", "", .)
}

# Noms nettoyés des produits
produits_nettoyes <- sapply(liste_produits_alimentaires, nettoyer_nom, USE.NAMES = FALSE)

# Création d'une table de correspondance entre produits nettoyés et noms originaux
produits_df <- data.frame(
  produit_clean = produits_nettoyes,
  produit_label = tolower(liste_produits_alimentaires),
  stringsAsFactors = FALSE
)

# Ajouter la colonne nom_produit dans chaque data frame
liste_datasets_cagette_nettoyee <- lapply(names(liste_datasets_cagette), function(nom_df) {
  df <- liste_datasets_cagette[[nom_df]]
  
  # Extraire le nom du produit dans le nom de la table
  produit_nom_match <- sub("cagette_(.*)_20[0-9]{2}", "\\1", nom_df)
  
  # Nettoyage de ce nom pour le faire correspondre
  produit_nom_clean <- nettoyer_nom(produit_nom_match)
  
  # Recherche du nom d'origine
  produit_label <- produits_df$produit_label[match(produit_nom_clean, produits_df$produit_clean)]
  
  # Ajoute directement le nom nettoyé (sans accents)
  df$nom_produit <- produits_df$produit_clean[match(produit_nom_clean, produits_df$produit_clean)]

  
  return(df)
})

# Réattribution des noms à la liste
names(liste_datasets_cagette_nettoyee) <- names(liste_datasets_cagette)

```

```{r}
# On fusionne toutes les tables de cagette en une seule
liste_finale_datasets_cagette <- do.call(rbind, liste_datasets_cagette_nettoyee)
```


# VIII) On vérifie la pertinence des données déjà classées par les fournisseurs 

```{r}

# On regarde toutes les déclinaisons de noms de produit possibles pour les fichiers cagette
vect_decli_cagette <- trouver_declinaisons_nom_produit(
    dataset = liste_finale_datasets_cagette,
    col_produit = "productName",
    ls_produit = liste_produits,
    regex = regex
  )
```


```{r}
# On attribue le bon nom de produit de la liste des 37 à chaque ligne 

# On retire la colonne contenant le type de produit 
liste_finale_datasets_cagette <- liste_finale_datasets_cagette |> select(-c(11))

# Test de la fonction : Fichier coop circuit 2021
system.time({ 
  liste_cagette_trie_et_pas_trie <- separation_fichiers(
  data = liste_finale_datasets_cagette,
  liste_produits = liste_produits,
  liste_declinai_noms_produits = vect_decli_cagette
)})


# On regarde séparemment le data_ok et data_pas_ok
cagette_prod_tries <- liste_cagette_trie_et_pas_trie$data_ok
cagette_prod_pas_tries <- liste_cagette_trie_et_pas_trie$data_pas_ok

```


# IX) Fusion de tous les fichiers de produits triés issus de toutes les plateformes

```{r}
# On supprime la colonne name_clean de data_prod_tries
data_prod_tries <- data_prod_tries |> select(-c("name_clean"))

# On supprime la colonne name_clean de cagette_prod_tries
cagette_prod_tries <- cagette_prod_tries |> select(-c("name_clean"))

# On fusionne toutes les tables de cagette en une seule
datasets_tts_plateformes_prod_tries <- rbind(cagette_prod_tries,data_prod_tries)

```


# X) Fusion des fichiers de produits pas triés en un seul 

```{r}

# On fusionne toutes les tables de cagette en une seule
data_prod_pas_tries_tts_platatefor <- rbind(cagette_prod_pas_tries,data_prod_pas_tries)

```

# XI) Indicateur de pureté pour les produits triés

```{r}

# Extraire les levels (uniques)
levels_productName <- unique(datasets_tts_plateformes_prod_tries$productName)
levels_nom_produit <- unique(datasets_tts_plateformes_prod_tries$nom_produit)

# Indicateur de pureté pour les produits triés
compter_occurrences_exclusives <- function(df, col_productName = "productName", col_nom_produit = "nom_produit") {
  # Étape 1 : trier les noms_produit du plus long au plus court (pour priorité aux plus spécifiques)
  levels_nom_produit <- unique(df[[col_nom_produit]])
  levels_nom_produit <- levels_nom_produit[order(nchar(levels_nom_produit), decreasing = TRUE)]
  
  # Étape 2 : récupérer tous les productName uniques
  all_product_names <- unique(df[[col_productName]])
  
  # Étape 3 : initialiser les noms déjà utilisés
  noms_assignés <- rep(FALSE, length(all_product_names))
  names(noms_assignés) <- all_product_names
  
  # Étape 4 : construire les tableaux
  resultats <- map(levels_nom_produit, function(nom_produit) {
    # Construire la regex pluriel + imbriqué
    mots <- str_split(nom_produit, " ")[[1]]
    mots_regex <- paste0("(", mots, ")(s|x)?")
    motif <- paste(mots_regex, collapse = "[- ]?")
    
    # Filtrer uniquement les noms encore disponibles
    names_disponibles <- all_product_names[!noms_assignés]
    
    # Compter les occurrences
    nb_occ <- str_count(tolower(names_disponibles), regex(motif, ignore_case = TRUE))
    
    # Conserver ceux avec une correspondance
    matched_names <- names_disponibles[nb_occ > 0]
    matched_counts <- nb_occ[nb_occ > 0]
    
    # Marquer ces noms comme assignés
    noms_assignés[matched_names] <<- TRUE
    
    # Retourner le tibble
    tibble(
      !!paste0("levels_", str_replace_all(nom_produit, " ", "_")) := matched_names,
      !!paste0("nb_occurrence_", str_replace_all(nom_produit, " ", "_")) := matched_counts
    )
  }) |> set_names(levels_nom_produit)
  
  return(resultats)
}


# On teste la fonction 
liste_table_indi_purete_prod_trie <- compter_occurrences_from_levels(levels_productName, levels_nom_produit)


```


# XII) On sépare en 37 tables

## a) Développement de la fonction pour split en 37 tables

```{r}

split_data_ok_par_produit <- function(data_ok) {
  # Vérification de la présence de la colonne nom_produit
  if (!"nom_produit" %in% colnames(data_ok)) {
    stop("La colonne 'nom_produit' est absente de data_ok")
  }

  # Découpage automatique en liste de data frames, un par produit
  liste_data_par_produit <- split(data_ok, data_ok$nom_produit)

  return(liste_data_par_produit)
}

```

## b) Application de la fonction

```{r}
# Test de la fonction : data_ok de coop circuit 2021
liste_tables_37_produit_bruts <- split_data_ok_par_produit(datasets_tts_plateformes_prod_tries)

# Accéder au sous-dataframe pour le produit "pomme"
data_tomate <- liste_tables_37_produit_bruts[["tomate"]]

# Voir tous les noms de produits
names(data_tomate)

```
